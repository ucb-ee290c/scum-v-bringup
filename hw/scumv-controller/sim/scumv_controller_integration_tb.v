/*
 * SCuM-V Controller Integration Testbench with TileLink Echo & Inspection
 * 
 * This testbench instantiates the complete a7top module and tests the STL
 * functionality by reading UART byte streams generated by tl_host_sim.py
 * and feeding them through a UART transmitter to simulate real host communication.
 * 
 * TileLink Echo Architecture:
 * - TL_OUT → GenericDeserializer (packet inspection) → GenericSerializer → TL_IN
 * - Provides realistic echo behavior with proper serialization/deserialization timing
 * - Captures complete TileLink packets for validation and debugging
 * 
 * Test flow:
 * 1. Read test vector file generated by tl_host_sim.py
 * 2. Feed bytes through UART transmitter to generate proper UART timing
 * 3. Connect UART output to a7top UART input
 * 4. TileLink packets sent via TL_OUT are echoed back via TL_IN
 * 5. GenericDeserializer inspects packets and displays all fields
 * 6. Comprehensive validation with content-based assertions
 * 7. Capture and verify UART response packets
 * 
 * Validation Features:
 * - Echo functionality: Commands are properly echoed back
 * - Packet inspection: Deserialized packets show exactly what was transmitted
 * - Content validation: Assertions verify packet field validity
 * - Pass/fail criteria: UART responses + TileLink packets + assertion results
 * 
 * Usage with Vivado:
 * 1. Generate test vectors: python tl_host_sim.py --generate-test-vectors -o sim_input.bin
 * 2. Run simulation with: sim:/scumv_controller_integration_tb
 */

`timescale 1ns / 1ps

module scumv_controller_integration_tb();

    // Test parameters
    parameter CLOCK_FREQ = 100_000_000;  // 100 MHz system clock
    parameter BAUD_RATE = 1_000_000;       // UART baud rate
    parameter TEST_VECTOR_FILE = "C:/Projects/Repositories/scum-v-bringup/hw/scumv-controller/sim/sim_input.bin";  // Input file from tl_host_sim.py
    parameter MAX_BYTES = 1024;          // Maximum test vector size
    parameter TIMEOUT_CYCLES = 5000000;  // Timeout for waiting operations
    
    // Clock and reset
    reg clk;
    reg reset_n;
    wire reset = ~reset_n;
    
    // Test control
    reg [7:0] test_vectors [0:MAX_BYTES-1];  // Test vector memory
    integer test_vector_size;                 // Actual size of loaded vectors
    integer current_byte;                     // Current byte being sent
    reg test_active;                          // Test is running
    reg [31:0] timeout_counter;               // Timeout counter
    
    // UART stimulus generation
    reg [7:0] uart_tx_data;
    reg uart_tx_valid;
    wire uart_tx_ready;
    wire uart_tx_serial;
    
    // UART response capture
    wire [7:0] uart_rx_data;
    wire uart_rx_valid;
    reg uart_rx_ready;
    wire uart_rx_serial;
    reg [7:0] response_buffer [0:255];       // Response capture buffer
    integer response_count;                   // Number of response bytes received
    
    // Device under test (DUT) - a7top module
    wire [3:0] led;
    
    // SerialTL interface - now with loopback and inspection
    reg tl_clk;
    wire tl_in_valid;
    wire tl_in_ready;
    wire tl_in_data;
    wire tl_out_valid;
    wire tl_out_ready;
    wire tl_out_data;
    
    // TileLink packet inspection signals
    wire tl_inspector_ready;
    wire tl_inspector_valid;
    wire [2:0] tl_inspector_chanId;
    wire [2:0] tl_inspector_opcode;
    wire [2:0] tl_inspector_param;
    wire [7:0] tl_inspector_size;
    wire [7:0] tl_inspector_source;
    wire [63:0] tl_inspector_address;
    wire [63:0] tl_inspector_data;
    wire tl_inspector_corrupt;
    wire [8:0] tl_inspector_union;
    
    // Mock ASC interface
    wire scan_clk, scan_en, scan_in, scan_reset;
    
    // TileLink packet inspector (deserializer for monitoring)
    GenericDeserializer tl_inspector (
        .clock(tl_clk),
        .reset(reset),
        .io_in_ready(tl_inspector_ready),    // Output - not used
        .io_in_valid(tl_out_valid),          // Input from DUT TL_OUT
        .io_in_bits(tl_out_data),            // Input from DUT TL_OUT
        .io_out_ready(1'b1),                 // Always ready to accept packets
        .io_out_valid(tl_inspector_valid),
        .io_out_bits_chanId(tl_inspector_chanId),
        .io_out_bits_opcode(tl_inspector_opcode),
        .io_out_bits_param(tl_inspector_param),
        .io_out_bits_size(tl_inspector_size),
        .io_out_bits_source(tl_inspector_source),
        .io_out_bits_address(tl_inspector_address),
        .io_out_bits_data(tl_inspector_data),
        .io_out_bits_corrupt(tl_inspector_corrupt),
        .io_out_bits_union(tl_inspector_union)
    );
    
    // TileLink echo serializer (re-serializes packets back to TL_IN)
    GenericSerializer tl_echo_serializer (
        .clock(tl_clk),
        .reset(reset),
        .io_in_ready(),                          // Not used - serializer always ready when not sending
        .io_in_valid(tl_inspector_valid),        // Input from deserializer
        .io_in_bits_chanId(tl_inspector_chanId),
        .io_in_bits_opcode(tl_inspector_opcode),
        .io_in_bits_param(tl_inspector_param),
        .io_in_bits_size(tl_inspector_size),
        .io_in_bits_source(tl_inspector_source),
        .io_in_bits_address(tl_inspector_address),
        .io_in_bits_data(tl_inspector_data),
        .io_in_bits_corrupt(tl_inspector_corrupt),
        .io_in_bits_union(tl_inspector_union),
        .io_in_bits_last(1'b1),                 // Always last bit for single packets
        .io_out_ready(tl_in_ready),              // Ready signal from DUT
        .io_out_valid(tl_in_valid),              // Output to DUT TL_IN
        .io_out_bits(tl_in_data)                 // Output to DUT TL_IN
    );
    
    // TL_OUT_READY comes from the deserializer (when it can accept more data)
    assign tl_out_ready = tl_inspector_ready;
    
    // Test validation variables
    integer packets_sent_count;
    integer packets_received_count;
    integer assertion_failures;
    reg test_passed;
    
    // UART stimulus generator (transmitter to feed data to DUT)
    uart #(
        .CLOCK_FREQ(CLOCK_FREQ),
        .BAUD_RATE(BAUD_RATE)
    ) uart_stimulus (
        .clk(clk),
        .reset(reset),
        .data_in(uart_tx_data),
        .data_in_valid(uart_tx_valid),
        .data_in_ready(uart_tx_ready),
        .data_out(),           // Not used for stimulus
        .data_out_valid(),     // Not used for stimulus  
        .data_out_ready(1'b0), // Not used for stimulus
        .serial_in(1'b1),      // Idle state
        .serial_out(uart_tx_serial)
    );
    
    // UART response capture (receiver to capture responses from DUT)
    uart #(
        .CLOCK_FREQ(CLOCK_FREQ),
        .BAUD_RATE(BAUD_RATE)
    ) uart_capture (
        .clk(clk),
        .reset(reset),
        .data_in(8'h00),       // Not used for capture
        .data_in_valid(1'b0),  // Not used for capture
        .data_in_ready(),      // Not used for capture
        .data_out(uart_rx_data),
        .data_out_valid(uart_rx_valid),
        .data_out_ready(uart_rx_ready),
        .serial_in(uart_rx_serial),  // Connected to DUT UART output
        .serial_out()          // Not used for capture
    );
    
    // Device Under Test - SCuM-V Controller
    a7top dut (
        .CLK100MHZ(clk),
        .RESET(reset_n),  // a7top expects active-high reset, reset_n is active-low
        .BUTTON_0(1'b1),   // Button not pressed (active-low)
        .led(led),
        
        // UART interface
        .UART_TXD_IN(uart_tx_serial),      // Input to FPGA from our stimulus generator
        .UART_RXD_IN(uart_rx_serial),      // Output from FPGA to our response capture
        
        // SerialTL interface (mocked)
        .TL_CLK(tl_clk),
        .TL_IN_VALID(tl_in_valid),
        .TL_IN_READY(tl_in_ready),
        .TL_IN_DATA(tl_in_data),
        .TL_OUT_VALID(tl_out_valid),
        .TL_OUT_READY(tl_out_ready),
        .TL_OUT_DATA(tl_out_data),
        
        // ASC interface (not used in this test) 
        .SCAN_CLK(scan_clk),
        .SCAN_EN(scan_en),
        .SCAN_IN(scan_in),
        .SCAN_RESET(scan_reset),
        .CHIP_RESET()  // Not connected in this test
    );
    
    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;  // 100 MHz clock (10ns period)
    end
    
    // TileLink clock generation (mock - 50 kHz)
    initial begin
        tl_clk = 0;
        forever #1000 tl_clk = ~tl_clk;  // 500 kHz TL clock (period = 2 us, half-period = 1 us = 1000 ns)
    end
    
    // Main test procedure
    initial begin
        $display("[TB] Starting SCuM-V Controller Integration Test");
        $display("[TB] Clock Freq: %0d Hz, BAUD Rate: %0d", CLOCK_FREQ, BAUD_RATE);
        
        // Initialize signals
        reset_n = 0;
        uart_tx_data = 8'h00;
        uart_tx_valid = 1'b0;
        uart_rx_ready = 1'b1;  // Always ready to receive responses
        current_byte = 0;
        test_active = 1'b0;
        response_count = 0;
        timeout_counter = 0;
        
        // Initialize test validation variables
        packets_sent_count = 0;
        packets_received_count = 0;
        assertion_failures = 0;
        test_passed = 1'b0;
        
        // TileLink interface is now active with loopback connections
        // (no initialization needed - handled by assign statements)
        
        // Load test vectors from file
        load_test_vectors();
        
        // Reset sequence
        $display("[TB] Applying reset...");
        #12000;
        reset_n = 1;
        #12000;
        $display("[TB] Reset released, starting test sequence");
        
        // Wait for system to settle
        #1000;
        
        // Start test sequence
        test_active = 1'b1;
        send_test_vectors();
        
        // Wait for all responses or timeout
        wait_for_responses();
        
        // Analyze results
        analyze_results();
        
        $display("[TB] Test completed");
        $finish;
    end
    
    // Load test vectors from file
    task load_test_vectors;
        integer file_handle, byte_val, i;
        begin
            $display("[TB] Loading test vectors from %s", TEST_VECTOR_FILE);
            
            file_handle = $fopen(TEST_VECTOR_FILE, "rb");
            if (file_handle == 0) begin
                $display("[TB] ERROR: Could not open test vector file %s", TEST_VECTOR_FILE);
                $display("[TB] Please run: python tl_host_sim.py --generate-test-vectors -o %s", TEST_VECTOR_FILE);
                $finish;
            end
            
            test_vector_size = 0;
            for (i = 0; i < MAX_BYTES; i = i + 1) begin
                byte_val = $fgetc(file_handle);
                if (byte_val == -1) begin
                    i = MAX_BYTES;  // Exit loop on EOF
                end else begin
                    test_vectors[i] = byte_val[7:0];
                    test_vector_size = test_vector_size + 1;
                end
            end
            
            $fclose(file_handle);
            $display("[TB] Loaded %0d bytes from test vector file", test_vector_size);
            
            // Display first few bytes for debugging
            $write("[TB] First 16 bytes: ");
            for (i = 0; i < 16 && i < test_vector_size; i = i + 1) begin
                $write("%02X ", test_vectors[i]);
            end
            $write("\n");
        end
    endtask
    
    // Send test vectors byte by byte through UART
    task send_test_vectors;
        integer i;
        begin
            $display("[TB] Sending %0d test vector bytes...", test_vector_size);
            
            for (i = 0; i < test_vector_size; i = i + 1) begin
                // Wait for UART transmitter to be ready
                wait_for_uart_ready();
                
                // Send next byte
                uart_tx_data = test_vectors[i];
                uart_tx_valid = 1'b1;
                @(posedge clk);
                @(posedge clk);
                // Wait for byte to be accepted
                wait (uart_tx_ready);
                uart_tx_valid = 1'b0;
                @(posedge clk);
                
                $display("[TB] Sent byte %0d: 0x%02X", i, test_vectors[i]);
                
                // Small delay between bytes (optional)
                repeat(10) @(posedge clk);
            end
            
            $display("[TB] All test vector bytes sent");
        end
    endtask
    
    // Wait for UART transmitter to be ready
    task wait_for_uart_ready;
        begin
            timeout_counter = 0;
            while (!uart_tx_ready && timeout_counter < TIMEOUT_CYCLES) begin
                @(posedge clk);
                timeout_counter = timeout_counter + 1;
            end
            
            if (timeout_counter >= TIMEOUT_CYCLES) begin
                $display("[TB] ERROR: Timeout waiting for UART TX ready");
                $finish;
            end
        end
    endtask
    
    // Wait for responses from DUT
    task wait_for_responses;
        begin
            $display("[TB] Waiting for responses...");
            timeout_counter = 0;
            
            // Wait for some time to collect responses
            // In a real test, you'd wait for specific response patterns
            while (timeout_counter < TIMEOUT_CYCLES) begin
                @(posedge clk);
                timeout_counter = timeout_counter + 1;
                
                // Check if we have reasonable amount of processing time
                if (timeout_counter > TIMEOUT_CYCLES/2 && response_count > 0) begin
                    $display("[TB] Received %0d response bytes, ending wait", response_count);
                    timeout_counter = TIMEOUT_CYCLES;  // Exit loop
                end
            end
            
            if (timeout_counter >= TIMEOUT_CYCLES) begin
                $display("[TB] Timeout waiting for responses (received %0d bytes)", response_count);
            end
        end
    endtask
    
    // Analyze test results
    task analyze_results;
        integer i;
        begin
            $display("[TB] ========== TEST RESULTS ==========");
            $display("[TB] Test vectors sent: %0d bytes", test_vector_size);
            $display("[TB] Response bytes received: %0d", response_count);
            
            if (response_count > 0) begin
                $write("[TB] Response bytes: ");
                for (i = 0; i < response_count && i < 32; i = i + 1) begin
                    $write("%02X ", response_buffer[i]);
                end
                if (response_count > 32) $write("... (truncated)");
                $write("\n");
            end
            
            // TileLink packet validation results
            $display("[TB] TileLink packets received: %0d", packets_received_count);
            $display("[TB] Assertion failures: %0d", assertion_failures);
            
            // Check LED status
            $display("[TB] Final LED status: %b", led);
            $display("[TB] LED[0] (n_reset): %b", led[0]);
            $display("[TB] LED[1] (ASC active): %b", led[1]); 
            $display("[TB] LED[2] (STL active): %b", led[2]);
            $display("[TB] LED[3] (TL_IN_VALID): %b", led[3]);
            
            // Comprehensive pass/fail criteria
            test_passed = 1'b1;  // Start with pass assumption
            
            if (response_count == 0) begin
                $display("[TB] FAIL: No UART response data received");
                test_passed = 1'b0;
            end else begin
                $display("[TB] PASS: Received %0d UART response bytes", response_count);
            end
            
            if (packets_received_count == 0) begin
                $display("[TB] FAIL: No TileLink packets captured");
                test_passed = 1'b0;
            end else begin
                $display("[TB] PASS: Captured %0d TileLink packets", packets_received_count);
            end
            
            if (assertion_failures > 0) begin
                $display("[TB] FAIL: %0d assertion failures detected", assertion_failures);
                test_passed = 1'b0;
            end else begin
                $display("[TB] PASS: No assertion failures");
            end
            
            // Final test result
            if (test_passed) begin
                $display("[TB] OVERALL RESULT: PASS - Echo functionality working correctly");
            end else begin
                $display("[TB] OVERALL RESULT: FAIL - Test validation failed");
            end
            
            $display("[TB] ===================================");
        end
    endtask
    
    // Response capture process
    always @(posedge clk) begin
        if (reset) begin
            response_count <= 0;
        end else if (uart_rx_valid && uart_rx_ready) begin
            if (response_count < 256) begin
                response_buffer[response_count] <= uart_rx_data;
                response_count <= response_count + 1;
                $display("[TB] Captured response byte %0d: 0x%02X", response_count, uart_rx_data);
            end
        end
    end
    
    // Monitor and validate deserialized TileLink packets
    always @(posedge tl_clk) begin
        if (tl_inspector_valid) begin
            packets_received_count = packets_received_count + 1;
            
            $display("[TB] ========== TILELINK PACKET CAPTURED ==========");
            $display("[TB] Packet #%0d", packets_received_count);
            $display("[TB] Channel ID: 0x%01X", tl_inspector_chanId);
            $display("[TB] Opcode:     0x%01X (%s)", tl_inspector_opcode, 
                     tl_inspector_opcode == 3'h0 ? "PutFullData" :
                     tl_inspector_opcode == 3'h1 ? "PutPartialData" :
                     tl_inspector_opcode == 3'h4 ? "Get" :
                     tl_inspector_opcode == 3'h0 ? "AccessAck" :
                     tl_inspector_opcode == 3'h1 ? "AccessAckData" : "Unknown");
            $display("[TB] Param:      0x%01X", tl_inspector_param);
            $display("[TB] Size:       0x%02X (%0d bytes)", tl_inspector_size, 1 << tl_inspector_size);
            $display("[TB] Source:     0x%02X", tl_inspector_source);
            $display("[TB] Address:    0x%016X", tl_inspector_address);
            $display("[TB] Data:       0x%016X", tl_inspector_data);
            $display("[TB] Corrupt:    %b", tl_inspector_corrupt);
            $display("[TB] Union:      0x%03X", tl_inspector_union);
            $display("[TB] =============================================");
            
            // Basic packet validation assertions (content only, not timing)
            if (tl_inspector_size > 8'h06) begin
                $error("[TB] ASSERTION FAILED: Invalid packet size: 0x%02X (max 0x06)", tl_inspector_size);
                assertion_failures = assertion_failures + 1;
            end
            
            if (tl_inspector_chanId > 3'h2) begin
                $error("[TB] ASSERTION FAILED: Invalid channel ID: 0x%01X (max 0x2)", tl_inspector_chanId);
                assertion_failures = assertion_failures + 1;
            end
            
            if (tl_inspector_opcode > 3'h6) begin
                $error("[TB] ASSERTION FAILED: Invalid opcode: 0x%01X (max 0x6)", tl_inspector_opcode);
                assertion_failures = assertion_failures + 1;
            end
        end
    end
    
    // Monitor for test timeout
    always @(posedge clk) begin
        if (test_active && timeout_counter > TIMEOUT_CYCLES) begin
            $display("[TB] ERROR: Test timeout exceeded");
            $finish;
        end
    end

endmodule