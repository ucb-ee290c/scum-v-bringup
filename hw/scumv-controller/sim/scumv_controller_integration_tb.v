/*
 * SCuM-V Controller Integration Testbench
 * 
 * This testbench instantiates the complete a7top module and tests the STL
 * functionality by reading UART byte streams generated by tl_host_sim.py
 * and feeding them through a UART transmitter to simulate real host communication.
 * 
 * Test flow:
 * 1. Read test vector file generated by tl_host_sim.py
 * 2. Feed bytes through UART transmitter to generate proper UART timing
 * 3. Connect UART output to a7top UART input
 * 4. Monitor STL interface signals and responses
 * 5. Capture and verify response packets
 * 
 * Usage with Vivado:
 * 1. Generate test vectors: python tl_host_sim.py --generate-test-vectors -o sim_input.bin
 * 2. Run simulation with: sim:/scumv_controller_integration_tb
 */

`timescale 1ns / 1ps

module scumv_controller_integration_tb();

    // Test parameters
    parameter CLOCK_FREQ = 100_000_000;  // 100 MHz system clock
    parameter BAUD_RATE = 921_600;       // UART baud rate (slower for simulation)
    parameter TEST_VECTOR_FILE = "C:/Projects/Repositories/scum-v-bringup/hw/scumv-controller/sim/sim_input.bin";  // Input file from tl_host_sim.py
    parameter MAX_BYTES = 1024;          // Maximum test vector size
    parameter TIMEOUT_CYCLES = 1000000;  // Timeout for waiting operations
    
    // Clock and reset
    reg clk;
    reg reset_n;
    wire reset = ~reset_n;
    
    // Test control
    reg [7:0] test_vectors [0:MAX_BYTES-1];  // Test vector memory
    integer test_vector_size;                 // Actual size of loaded vectors
    integer current_byte;                     // Current byte being sent
    reg test_active;                          // Test is running
    reg [31:0] timeout_counter;               // Timeout counter
    
    // UART stimulus generation
    reg [7:0] uart_tx_data;
    reg uart_tx_valid;
    wire uart_tx_ready;
    wire uart_tx_serial;
    
    // UART response capture
    wire [7:0] uart_rx_data;
    wire uart_rx_valid;
    reg uart_rx_ready;
    wire uart_rx_serial;
    reg [7:0] response_buffer [0:255];       // Response capture buffer
    integer response_count;                   // Number of response bytes received
    
    // Device under test (DUT) - a7top module
    wire [3:0] led;
    
    // Mock SerialTL interface (since we're only testing UART/STL path)
    reg tl_clk;
    reg tl_in_valid;
    wire tl_in_ready;
    reg tl_in_data;
    wire tl_out_valid;
    reg tl_out_ready;
    wire tl_out_data;
    
    // Mock ASC interface
    wire scan_clk, scan_en, scan_in, scan_reset;
    
    // UART stimulus generator (transmitter to feed data to DUT)
    uart #(
        .CLOCK_FREQ(CLOCK_FREQ),
        .BAUD_RATE(BAUD_RATE)
    ) uart_stimulus (
        .clk(clk),
        .reset(reset),
        .data_in(uart_tx_data),
        .data_in_valid(uart_tx_valid),
        .data_in_ready(uart_tx_ready),
        .data_out(),           // Not used for stimulus
        .data_out_valid(),     // Not used for stimulus  
        .data_out_ready(1'b0), // Not used for stimulus
        .serial_in(1'b1),      // Idle state
        .serial_out(uart_tx_serial)
    );
    
    // UART response capture (receiver to capture responses from DUT)
    uart #(
        .CLOCK_FREQ(CLOCK_FREQ),
        .BAUD_RATE(BAUD_RATE)
    ) uart_capture (
        .clk(clk),
        .reset(reset),
        .data_in(8'h00),       // Not used for capture
        .data_in_valid(1'b0),  // Not used for capture
        .data_in_ready(),      // Not used for capture
        .data_out(uart_rx_data),
        .data_out_valid(uart_rx_valid),
        .data_out_ready(uart_rx_ready),
        .serial_in(uart_rx_serial),  // Connected to DUT UART output
        .serial_out()          // Not used for capture
    );
    
    // Device Under Test - SCuM-V Controller
    a7top dut (
        .CLK100MHZ(clk),
        .RESET(reset_n),  // a7top expects active-high reset, reset_n is active-low
        .BUTTON_0(1'b1),   // Button not pressed (active-low)
        .led(led),
        
        // UART interface
        .UART_TXD_IN(uart_tx_serial),      // Input to FPGA from our stimulus generator
        .UART_RXD_IN(uart_rx_serial),      // Output from FPGA to our response capture
        
        // SerialTL interface (mocked)
        .TL_CLK(tl_clk),
        .TL_IN_VALID(tl_in_valid),
        .TL_IN_READY(tl_in_ready),
        .TL_IN_DATA(tl_in_data),
        .TL_OUT_VALID(tl_out_valid),
        .TL_OUT_READY(tl_out_ready),
        .TL_OUT_DATA(tl_out_data),
        
        // ASC interface (not used in this test) 
        .SCAN_CLK(scan_clk),
        .SCAN_EN(scan_en),
        .SCAN_IN(scan_in),
        .SCAN_RESET(scan_reset),
        .CHIP_RESET()  // Not connected in this test
    );
    
    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;  // 100 MHz clock (10ns period)
    end
    
    // TileLink clock generation (mock - faster than system clock)
    initial begin
        tl_clk = 0;
        forever #2 tl_clk = ~tl_clk;  // 250 MHz TL clock
    end
    
    // Main test procedure
    initial begin
        $display("[TB] Starting SCuM-V Controller Integration Test");
        $display("[TB] Clock Freq: %0d Hz, BAUD Rate: %0d", CLOCK_FREQ, BAUD_RATE);
        
        // Initialize signals
        reset_n = 0;
        uart_tx_data = 8'h00;
        uart_tx_valid = 1'b0;
        uart_rx_ready = 1'b1;  // Always ready to receive responses
        current_byte = 0;
        test_active = 1'b0;
        response_count = 0;
        timeout_counter = 0;
        
        // Mock TileLink interface (not active for this test)
        tl_in_valid = 1'b0;
        tl_in_data = 1'b0;
        tl_out_ready = 1'b1;
        
        // Load test vectors from file
        load_test_vectors();
        
        // Reset sequence
        $display("[TB] Applying reset...");
        #100;
        reset_n = 1;
        #100;
        $display("[TB] Reset released, starting test sequence");
        
        // Wait for system to settle
        #1000;
        
        // Start test sequence
        test_active = 1'b1;
        send_test_vectors();
        
        // Wait for all responses or timeout
        wait_for_responses();
        
        // Analyze results
        analyze_results();
        
        $display("[TB] Test completed");
        $finish;
    end
    
    // Load test vectors from file
    task load_test_vectors;
        integer file_handle, byte_val, i;
        begin
            $display("[TB] Loading test vectors from %s", TEST_VECTOR_FILE);
            
            file_handle = $fopen(TEST_VECTOR_FILE, "rb");
            if (file_handle == 0) begin
                $display("[TB] ERROR: Could not open test vector file %s", TEST_VECTOR_FILE);
                $display("[TB] Please run: python tl_host_sim.py --generate-test-vectors -o %s", TEST_VECTOR_FILE);
                $finish;
            end
            
            test_vector_size = 0;
            for (i = 0; i < MAX_BYTES; i = i + 1) begin
                byte_val = $fgetc(file_handle);
                if (byte_val == -1) begin
                    i = MAX_BYTES;  // Exit loop on EOF
                end else begin
                    test_vectors[i] = byte_val[7:0];
                    test_vector_size = test_vector_size + 1;
                end
            end
            
            $fclose(file_handle);
            $display("[TB] Loaded %0d bytes from test vector file", test_vector_size);
            
            // Display first few bytes for debugging
            $write("[TB] First 16 bytes: ");
            for (i = 0; i < 16 && i < test_vector_size; i = i + 1) begin
                $write("%02X ", test_vectors[i]);
            end
            $write("\n");
        end
    endtask
    
    // Send test vectors byte by byte through UART
    task send_test_vectors;
        integer i;
        begin
            $display("[TB] Sending %0d test vector bytes...", test_vector_size);
            
            for (i = 0; i < test_vector_size; i = i + 1) begin
                // Wait for UART transmitter to be ready
                wait_for_uart_ready();
                
                // Send next byte
                uart_tx_data = test_vectors[i];
                uart_tx_valid = 1'b1;
                @(posedge clk);
                @(posedge clk);
                // Wait for byte to be accepted
                wait (uart_tx_ready);
                uart_tx_valid = 1'b0;
                @(posedge clk);
                
                $display("[TB] Sent byte %0d: 0x%02X", i, test_vectors[i]);
                
                // Small delay between bytes (optional)
                repeat(10) @(posedge clk);
            end
            
            $display("[TB] All test vector bytes sent");
        end
    endtask
    
    // Wait for UART transmitter to be ready
    task wait_for_uart_ready;
        begin
            timeout_counter = 0;
            while (!uart_tx_ready && timeout_counter < TIMEOUT_CYCLES) begin
                @(posedge clk);
                timeout_counter = timeout_counter + 1;
            end
            
            if (timeout_counter >= TIMEOUT_CYCLES) begin
                $display("[TB] ERROR: Timeout waiting for UART TX ready");
                $finish;
            end
        end
    endtask
    
    // Wait for responses from DUT
    task wait_for_responses;
        begin
            $display("[TB] Waiting for responses...");
            timeout_counter = 0;
            
            // Wait for some time to collect responses
            // In a real test, you'd wait for specific response patterns
            while (timeout_counter < TIMEOUT_CYCLES) begin
                @(posedge clk);
                timeout_counter = timeout_counter + 1;
                
                // Check if we have reasonable amount of processing time
                if (timeout_counter > TIMEOUT_CYCLES/2 && response_count > 0) begin
                    $display("[TB] Received %0d response bytes, ending wait", response_count);
                    timeout_counter = TIMEOUT_CYCLES;  // Exit loop
                end
            end
            
            if (timeout_counter >= TIMEOUT_CYCLES) begin
                $display("[TB] Timeout waiting for responses (received %0d bytes)", response_count);
            end
        end
    endtask
    
    // Analyze test results
    task analyze_results;
        integer i;
        begin
            $display("[TB] ========== TEST RESULTS ==========");
            $display("[TB] Test vectors sent: %0d bytes", test_vector_size);
            $display("[TB] Response bytes received: %0d", response_count);
            
            if (response_count > 0) begin
                $write("[TB] Response bytes: ");
                for (i = 0; i < response_count && i < 32; i = i + 1) begin
                    $write("%02X ", response_buffer[i]);
                end
                if (response_count > 32) $write("... (truncated)");
                $write("\n");
            end
            
            // Check LED status
            $display("[TB] Final LED status: %b", led);
            $display("[TB] LED[0] (n_reset): %b", led[0]);
            $display("[TB] LED[1] (ASC active): %b", led[1]); 
            $display("[TB] LED[2] (STL active): %b", led[2]);
            $display("[TB] LED[3] (TL_IN_VALID): %b", led[3]);
            
            // Basic pass/fail criteria
            if (response_count > 0) begin
                $display("[TB] PASS: Received response data from STL controller");
            end else begin
                $display("[TB] FAIL: No response data received");
            end
            
            $display("[TB] ===================================");
        end
    endtask
    
    // Response capture process
    always @(posedge clk) begin
        if (reset) begin
            response_count <= 0;
        end else if (uart_rx_valid && uart_rx_ready) begin
            if (response_count < 256) begin
                response_buffer[response_count] <= uart_rx_data;
                response_count <= response_count + 1;
                $display("[TB] Captured response byte %0d: 0x%02X", response_count, uart_rx_data);
            end
        end
    end
    
    // Monitor STL interface activity
    always @(posedge clk) begin
        if (tl_out_valid && tl_out_ready) begin
            $display("[TB] STL TL_OUT transaction: data=%b", tl_out_data);
        end
    end
    
    // Monitor for test timeout
    always @(posedge clk) begin
        if (test_active && timeout_counter > TIMEOUT_CYCLES) begin
            $display("[TB] ERROR: Test timeout exceeded");
            $finish;
        end
    end

endmodule