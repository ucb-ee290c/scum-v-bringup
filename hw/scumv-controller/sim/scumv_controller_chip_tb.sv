`timescale 1ns / 1ps

/*
 * SCuM-V Controller + ChipTop Integration Testbench (no backpressure)
 *
 * - Instantiates `a7top` (FPGA) and `ChipTop` (SoC) and connects their SerialTL links
 * - Drives UART stimulus into `a7top` using vectors generated by tl_host_sim.py
 * - Captures UART responses from `a7top`
 * - ChipTop's serial_tl_0_clock_out clocks the SerialTL link; no artificial backpressure
 */

module scumv_controller_chip_tb();

	// Test parameters
	parameter CLOCK_FREQ = 100_000_000;  // 100 MHz system clock for a7top
	// Uncore (CPU) clock for ChipTop (default 1 MHz)
	parameter integer UNCORE_CLOCK_FREQ_HZ = 1_000_000;
	localparam integer UNCORE_CLK_HALF_PERIOD_NS = (1_000_000_000 / UNCORE_CLOCK_FREQ_HZ) / 2;
	parameter BAUD_RATE = 2_000_000;     // UART baud rate
	parameter TEST_VECTOR_FILE = "C:/Projects/Repositories/scum-v-bringup/hw/scumv-controller/sim/stl_flash_stress_4096pkts.bin";  // Input file from tl_host_sim.py
	parameter MAX_BYTES = 1048576;       // Maximum test vector size (1 MiB)
	parameter TIMEOUT_CYCLES = 5000000;  // Timeout for waiting operations
	parameter STOP_ON_FAIL   = 1;        // Pause simulation on first assertion failure

	// STL batching parameters to mimic tl_host.py batched streaming
	parameter PACKET_LEN_STL = 20;            // 4-byte "stl+" prefix + 16-byte TL payload
	parameter PACKETS_PER_BATCH = 64;         // Number of STL packets per batch
	parameter INTER_BYTE_GAP_CYCLES = 0;      // Extra gaps beyond UART stop bit (keep 0)
	parameter BATCH_DELAY_TL_CYCLES = 16;     // TL cycles to wait between batches

	// Clocks and reset
	reg clk;           // a7top system clock (100 MHz)
	reg reset_n;       // active-low reset to a7top
	wire reset = ~reset_n; // active-high reset for testbench helpers

	// Log file descriptor for mirroring $display output to a file
	integer tb_log_fd;

	// Test control
	reg [7:0] test_vectors [0:MAX_BYTES-1];  // Test vector memory
	integer test_vector_size;                 // Actual size of loaded vectors
	reg test_active;                          // Test is running
	reg [31:0] timeout_counter;               // Timeout counter
	integer stl_packet_count_total;           // Count of STL packets detected in input
	integer packet_offsets [0:MAX_BYTES-1];   // Byte offsets for each detected STL packet

	// UART stimulus generation
	reg [7:0] uart_tx_data;
	reg uart_tx_valid;
	wire uart_tx_ready;
	wire uart_tx_serial;  // Into a7top (UART_RX of the board)

	// UART response capture
	wire [7:0] uart_rx_data;
	wire uart_rx_valid;
	reg uart_rx_ready;
	wire uart_rx_serial;  // From a7top (UART_TX of the board)
	reg [7:0] response_buffer [0:255];       // Response capture buffer
	integer response_count;                   // Number of response bytes received

	// a7top DUT
	wire [3:0] led;

	// SerialTL link wires between a7top and ChipTop
	wire tl_clk;            // From ChipTop
	wire tl_in_valid;       // Into a7top (from ChipTop)
	wire tl_in_ready;       // From a7top (to ChipTop)
	wire tl_in_data;        // Into a7top (from ChipTop)
	wire tl_out_valid;      // From a7top (to ChipTop)
	wire tl_out_ready;      // Into a7top (from ChipTop)
	wire tl_out_data;       // From a7top (to ChipTop)

	// DigitalTop SerialTL wires (only ones we use)
	wire chip_serial_tl_clock_out;
	wire chip_serial_tl_in_ready;
	wire chip_serial_tl_out_valid;
	wire chip_serial_tl_out_bits;

	// Clocks required by ChipTop peripherals
	reg clk_sensoradc;
	reg clk_baseband;
	reg clk_rtc;
	reg clk_afe;
	reg clk_uncore;

	// Minimal constant inputs to ChipTop
	wire jtag_TRSTn = 1'b1; // keep JTAG out of reset
	wire jtag_TCK   = 1'b0;
	wire jtag_TMS   = 1'b0;
	wire jtag_TDI   = 1'b0;
	wire custom_boot = 1'b1; // enable custom boot path

	// UART stimulus generator (transmitter to feed data to a7top)
	uart #(
		.CLOCK_FREQ(CLOCK_FREQ),
		.BAUD_RATE(BAUD_RATE)
	) uart_stimulus (
		.clk(clk),
		.reset(reset),
		.data_in(uart_tx_data),
		.data_in_valid(uart_tx_valid),
		.data_in_ready(uart_tx_ready),
		.data_out(),
		.data_out_valid(),
		.data_out_ready(1'b0),
		.serial_in(1'b1),
		.serial_out(uart_tx_serial)
	);

	// UART response capture (receiver to capture responses from a7top)
	uart #(
		.CLOCK_FREQ(CLOCK_FREQ),
		.BAUD_RATE(BAUD_RATE)
	) uart_capture (
		.clk(clk),
		.reset(reset),
		.data_in(8'h00),
		.data_in_valid(1'b0),
		.data_in_ready(),
		.data_out(uart_rx_data),
		.data_out_valid(uart_rx_valid),
		.data_out_ready(uart_rx_ready),
		.serial_in(uart_rx_serial),
		.serial_out()
	);

	// a7top (FPGA proxy)
	a7top dut_fpga (
		.CLK100MHZ(clk),
		.RESET(reset_n),
		.BUTTON_0(1'b1),
		.led(led),
		// UART connection to host stimulus/capture
		.UART_TXD_IN(uart_tx_serial),
		.UART_RXD_IN(uart_rx_serial),
		// SerialTL connection to ChipTop
		.TL_CLK(tl_clk),
		.TL_IN_VALID(tl_in_valid),
		.TL_IN_READY(tl_in_ready),
		.TL_IN_DATA(tl_in_data),
		.TL_OUT_VALID(tl_out_valid),
		.TL_OUT_READY(tl_out_ready),
		.TL_OUT_DATA(tl_out_data),
		// ASC interface not used
		.SCAN_CLK(), .SCAN_EN(), .SCAN_IN(), .SCAN_RESET(), .CHIP_RESET()
	);

	// DigitalTop (SoC under test) - bypass ChipTop IO cells
	DigitalTop soc (
		// Uncore domain clock/reset
		.auto_chipyard_prcictrl_domain_reset_setter_clock_in_member_allClocks_uncore_clock(clk_uncore),
		.auto_chipyard_prcictrl_domain_reset_setter_clock_in_member_allClocks_uncore_reset(reset),
		// Tie off debug/JTAG (not used)
		.debug_clock(clk_uncore),
		.debug_reset(reset),
		.debug_systemjtag_jtag_TCK(1'b0),
		.debug_systemjtag_jtag_TMS(1'b0),
		.debug_systemjtag_jtag_TDI(1'b0),
		.debug_systemjtag_reset(1'b0),
		.debug_dmactiveAck(1'b1),
		// Boot control
		.custom_boot(custom_boot),
		// SerialTL (Chipyard serdes interface)
		.serial_tl_0_in_ready(chip_serial_tl_in_ready),
		.serial_tl_0_in_valid(tl_out_valid),
		.serial_tl_0_in_bits(tl_out_data),
		.serial_tl_0_out_ready(tl_in_ready),
		.serial_tl_0_out_valid(chip_serial_tl_out_valid),
		.serial_tl_0_out_bits(chip_serial_tl_out_bits),
		.serial_tl_0_clock_out(chip_serial_tl_clock_out),
		// Baseband and misc clocks
		.baseband_io_adc_clock(clk_baseband),
		// Minimal baseband inputs
		.baseband_io_data_rx_i_data(8'h0),
		.baseband_io_data_rx_i_valid(1'b0),
		.baseband_io_data_rx_q_data(8'h0),
		.baseband_io_data_rx_q_valid(1'b0),
		.baseband_io_tuning_trim_g1(8'h0),
		// Sensor ADC
		.sensoradc_adc_counter_p(6'h0),
		.sensoradc_adc_counter_n(6'h0),
		.sensoradc_adc_clock(clk_sensoradc),
		// AFE
		.afe_io_adc_clock(clk_afe),
		.afe_io_adc_output_valid(1'b0),
		.afe_io_adc_output_bits(10'h0),
		.afe_io_general_trim_afe_out_valid(1'b0),
		.afe_io_general_trim_afe_out_bits(8'h0),
		// RTC
		.rtc_timer_io_rtc_clock(clk_rtc),
		// UART (unused)
		.uart_0_rxd(1'b1),
		// GPIO inputs (tie low)
		.gpio_0_pins_0_i_ival(1'b0),
		.gpio_0_pins_1_i_ival(1'b0),
		.gpio_0_pins_2_i_ival(1'b0),
		.gpio_0_pins_3_i_ival(1'b0),
		.gpio_0_pins_4_i_ival(1'b0),
		.gpio_0_pins_5_i_ival(1'b0),
		.gpio_0_pins_6_i_ival(1'b0),
		.gpio_0_pins_7_i_ival(1'b0),
		// QSPI inputs (tie low)
		.qspi_0_dq_0_i(1'b0),
		.qspi_0_dq_1_i(1'b0),
		.qspi_0_dq_2_i(1'b0),
		.qspi_0_dq_3_i(1'b0),
		// Reset controller hart-in-reset status (tie to reset)
		.resetctrl_hartIsInReset_0(reset)
	);

	// Connect SerialTL between ChipTop and a7top
	assign tl_clk = chip_serial_tl_clock_out;
	assign tl_in_valid = chip_serial_tl_out_valid;
	assign tl_in_data  = chip_serial_tl_out_bits;
	assign tl_out_ready = chip_serial_tl_in_ready;

	// Clock generators for ChipTop (simple togglers)
	initial begin
		clk_sensoradc = 1'b0; // ~32 MHz (31.25 ns period)
		forever #15.625 clk_sensoradc = ~clk_sensoradc;
	end
	initial begin
		clk_baseband = 1'b0; // ~32 MHz
		forever #15.625 clk_baseband = ~clk_baseband;
	end
	initial begin
		clk_rtc = 1'b0; // 1 MHz (1000 ns period)
		forever #500 clk_rtc = ~clk_rtc;
	end
	initial begin
		clk_afe = 1'b0; // ~32 MHz
		forever #15.625 clk_afe = ~clk_afe;
	end
	initial begin
		clk_uncore = 1'b0; // Uncore (CPU) clock as parameterized
		forever #UNCORE_CLK_HALF_PERIOD_NS clk_uncore = ~clk_uncore;
	end

	// a7top system clock (100 MHz)
	initial begin
		clk = 0;
		forever #5 clk = ~clk;
	end

	// Main test procedure
	initial begin
		// Open log file early so all subsequent messages are mirrored to file as well
		tb_log_fd = $fopen("scumv_controller_chip_tb.log", "w");
		$display("[TB] Starting SCuM-V Controller + ChipTop Integration Test (no backpressure)");
		if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Starting SCuM-V Controller + ChipTop Integration Test (no backpressure)");
		$display("[TB] Clock Freq: %0d Hz, BAUD Rate: %0d", CLOCK_FREQ, BAUD_RATE);
		if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Clock Freq: %0d Hz, BAUD Rate: %0d", CLOCK_FREQ, BAUD_RATE);

		// Initialize signals
		reset_n = 0;
		uart_tx_data = 8'h00;
		uart_tx_valid = 1'b0;
		uart_rx_ready = 1'b1;  // Always ready to receive responses
		test_active = 1'b0;
		response_count = 0;
		timeout_counter = 0;

		// Load test vectors from file
		load_test_vectors();

		// Reset sequence
		$display("[TB] Applying reset...");
		if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Applying reset...");
		#12000;
		reset_n = 1;
		#12000;
		$display("[TB] Reset released, starting test sequence");
		if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Reset released, starting test sequence");

		// Wait for system to settle
		#1000;

		// Start test sequence
		test_active = 1'b1;
		send_test_vectors();

		// Wait for all responses or timeout
		wait_for_responses();

		// Analyze results
		analyze_results();

		$display("[TB] Test completed");
		if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Test completed");
		if (tb_log_fd) $fclose(tb_log_fd);
		$finish;
	end

	// (No STOP_ON_FAIL pause logic needed here; kept simple)

	// Load test vectors from file
	task load_test_vectors;
		integer file_handle, byte_val, i;
		begin
			$display("[TB] Loading test vectors from %s", TEST_VECTOR_FILE);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Loading test vectors from %s", TEST_VECTOR_FILE);

			file_handle = $fopen(TEST_VECTOR_FILE, "rb");
			if (file_handle == 0) begin
				$display("[TB] ERROR: Could not open test vector file %s", TEST_VECTOR_FILE);
				if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] ERROR: Could not open test vector file %s", TEST_VECTOR_FILE);
				$display("[TB] Please run: python tl_host_sim.py --generate-test-vectors -o %s", TEST_VECTOR_FILE);
				if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Please run: python tl_host_sim.py --generate-test-vectors -o %s", TEST_VECTOR_FILE);
				$finish;
			end

			test_vector_size = 0;
			for (i = 0; i < MAX_BYTES; i = i + 1) begin
				byte_val = $fgetc(file_handle);
				if (byte_val == -1) begin
					i = MAX_BYTES;  // Exit loop on EOF
				end else begin
					test_vectors[i] = byte_val[7:0];
					test_vector_size = test_vector_size + 1;
				end
			end

			$fclose(file_handle);
			$display("[TB] Loaded %0d bytes from test vector file", test_vector_size);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Loaded %0d bytes from test vector file", test_vector_size);

			// Display first few bytes for debugging
			$write("[TB] First 16 bytes: ");
			for (i = 0; i < 16 && i < test_vector_size; i = i + 1) begin
				$write("%02X ", test_vectors[i]);
			end
			$write("\n");
		end
	endtask

	// Count STL packets by scanning for "stl+" prefix every PACKET_LEN_STL bytes
	task count_stl_packets;
		integer i, j, preview_end, base0;
		begin
			stl_packet_count_total = 0;
			i = 0;
			while (i + 3 < test_vector_size) begin
				if (test_vectors[i]   == 8'h73 && // 's'
					test_vectors[i+1] == 8'h74 && // 't'
					test_vectors[i+2] == 8'h6C && // 'l'
					test_vectors[i+3] == 8'h2B)   // '+'
				begin
					packet_offsets[stl_packet_count_total] = i;
					stl_packet_count_total = stl_packet_count_total + 1;
					i = i + PACKET_LEN_STL;
				end else begin
					i = i + 1;
				end
			end
			$display("[TB] Detected %0d STL packets (PACKET_LEN_STL=%0d)", stl_packet_count_total, PACKET_LEN_STL);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Detected %0d STL packets (PACKET_LEN_STL=%0d)", stl_packet_count_total, PACKET_LEN_STL);
			if (stl_packet_count_total > 0) begin
				base0 = packet_offsets[0];
				preview_end = (base0 + 8 <= test_vector_size) ? base0 + 8 : test_vector_size;
				$write("[TB] First packet bytes at offset %0d: ", base0);
				for (j = base0; j < preview_end; j = j + 1) $write("%02X ", test_vectors[j]);
				$write("\n");
			end
		end
	endtask

	// Send a batch of STL packets continuously over UART (mimics tl_host batched streaming)
	task send_stl_batch(input integer start_packet_idx, input integer num_packets);
		integer pkt, byte_idx, base_idx, tl_pause_cnt;
		begin
			for (pkt = 0; pkt < num_packets; pkt = pkt + 1) begin
				base_idx = packet_offsets[start_packet_idx + pkt];
				// Send one full 20-byte STL command: "stl+" + 16B TL payload
				for (byte_idx = 0; byte_idx < PACKET_LEN_STL; byte_idx = byte_idx + 1) begin
					// Ensure transmitter is ready before presenting the byte
					wait_for_uart_ready();
					uart_tx_data  = test_vectors[base_idx + byte_idx];
					uart_tx_valid = 1'b1;
					@(posedge clk);
					// Confirm transmitter has started (ready dropped), then release VALID
					wait (!uart_tx_ready);
					uart_tx_valid = 1'b0;
					// Wait until transmitter finishes current byte (ready high again)
					wait (uart_tx_ready);
					// Optional minimal gap between bytes (keep 0 to stress DUT)
					repeat(INTER_BYTE_GAP_CYCLES) @(posedge clk);
				end
				$display("[TB] Sent STL packet #%0d (byte range %0d..%0d)",
						 start_packet_idx + pkt,
						 base_idx,
						 base_idx + PACKET_LEN_STL - 1);
				if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Sent STL packet #%0d (byte range %0d..%0d)",
						 start_packet_idx + pkt,
						 base_idx,
						 base_idx + PACKET_LEN_STL - 1);
			end
			// Optional pause between batches to emulate host think time
			if (BATCH_DELAY_TL_CYCLES > 0) begin
				for (tl_pause_cnt = 0; tl_pause_cnt < BATCH_DELAY_TL_CYCLES; tl_pause_cnt = tl_pause_cnt + 1)
					@(posedge tl_clk);
			end
		end
	endtask

	// Send test vectors as STL packets in batches (no artificial per-byte delays)
	task send_test_vectors;
		integer total_batches, b, remaining, count_this_batch, start_pkt;
		begin
			$display("[TB] Preparing to send STL packets in batches of %0d", PACKETS_PER_BATCH);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Preparing to send STL packets in batches of %0d", PACKETS_PER_BATCH);
			count_stl_packets();

			total_batches = (stl_packet_count_total + PACKETS_PER_BATCH - 1) / PACKETS_PER_BATCH;
			for (b = 0; b < total_batches; b = b + 1) begin
				start_pkt = b * PACKETS_PER_BATCH;
				remaining = stl_packet_count_total - start_pkt;
				count_this_batch = (remaining > PACKETS_PER_BATCH) ? PACKETS_PER_BATCH : remaining;
				$display("[TB] Sending batch %0d/%0d: %0d packets (start index %0d)",
						 b+1, total_batches, count_this_batch, start_pkt);
				if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Sending batch %0d/%0d: %0d packets (start index %0d)",
						 b+1, total_batches, count_this_batch, start_pkt);
				send_stl_batch(start_pkt, count_this_batch);
			end
			$display("[TB] All STL packets sent: %0d", stl_packet_count_total);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] All STL packets sent: %0d", stl_packet_count_total);
		end
	endtask

	// Wait for UART transmitter to be ready
	task wait_for_uart_ready;
		begin
			timeout_counter = 0;
			while (!uart_tx_ready && timeout_counter < TIMEOUT_CYCLES) begin
				@(posedge clk);
				timeout_counter = timeout_counter + 1;
			end

			if (timeout_counter >= TIMEOUT_CYCLES) begin
				$display("[TB] ERROR: Timeout waiting for UART TX ready");
				if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] ERROR: Timeout waiting for UART TX ready");
				$finish;
			end
		end
	endtask

	// Wait for responses from a7top
	task wait_for_responses;
		integer expected_bytes;
		begin
			expected_bytes = stl_packet_count_total * 16; // 16 bytes per STL response
			$display("[TB] Waiting for ~%0d response bytes (for %0d packets)", expected_bytes, stl_packet_count_total);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Waiting for ~%0d response bytes (for %0d packets)", expected_bytes, stl_packet_count_total);
			timeout_counter = 0;

			while ((response_count < expected_bytes) && (timeout_counter < TIMEOUT_CYCLES)) begin
				@(posedge clk);
				timeout_counter = timeout_counter + 1;
			end

			if (response_count < expected_bytes) begin
				$display("[TB] WARN: Expected ~%0d response bytes, got %0d", expected_bytes, response_count);
				if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] WARN: Expected ~%0d response bytes, got %0d", expected_bytes, response_count);
			end else begin
				$display("[TB] Collected expected %0d response bytes", response_count);
				if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Collected expected %0d response bytes", response_count);
			end
		end
	endtask

	// Analyze test results
	task analyze_results;
		integer i;
		begin
			$display("[TB] ========== TEST RESULTS ==========");
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] ========== TEST RESULTS ==========");
			$display("[TB] Test vectors sent: %0d bytes", test_vector_size);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Test vectors sent: %0d bytes", test_vector_size);
			$display("[TB] Response bytes received: %0d", response_count);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Response bytes received: %0d", response_count);

			if (response_count > 0) begin
				$write("[TB] Response bytes: ");
				for (i = 0; i < response_count && i < 32; i = i + 1) begin
					$write("%02X ", response_buffer[i]);
				end
				if (response_count > 32) $write("... (truncated)");
				$write("\n");
			end

			$display("[TB] LED status: %b", led);
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] LED status: %b", led);

			$display("[TB] ===================================");
			if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] ===================================");
		end
	endtask

	// Response capture process
	always @(posedge clk) begin
		if (reset) begin
			response_count <= 0;
		end else if (uart_rx_valid && uart_rx_ready) begin
			if (response_count < 256) begin
				response_buffer[response_count] <= uart_rx_data;
				response_count <= response_count + 1;
				$display("[TB] Captured response byte %0d: 0x%02X", response_count, uart_rx_data);
				if (tb_log_fd) $fdisplay(tb_log_fd, "[TB] Captured response byte %0d: 0x%02X", response_count, uart_rx_data);
			end
		end
	end

endmodule


