(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[752],{6441:function(e,t,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/digital-baseband",function(){return i(5726)}])},5726:function(e,t,i){"use strict";i.r(t),i.d(t,{default:function(){return A},useTOC:function(){return f}});var n=i(5893),r=i(7812),d=i(8619),s=i(8925),a={src:"/scum-v-bringup/_next/static/media/tx_chain_diagram.079187b8.png",height:487,width:1255,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAIAAAAhqtkfAAAAQ0lEQVR42gVAQQqAMAxLm8Gm/v+JehaUadE1wyQ98Zo+kwDQ4WV1FjvO3VGaqzolODLA6w/r0XvcIxttEXKkbTXJMQECCSKdbliMngAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:3},l={src:"/scum-v-bringup/_next/static/media/rx_chain_diagram.4c1122d3.png",height:626,width:1385,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAAZElEQVR42h3GTQtAMBgA4P3/H+SmUA6SUjistDiQhXxs7N3sw9pzepBQAqQCUJ7RxgVKSxS3UdEeZccuZtdzr0g+0B5PHfK7l5rTho0xIWmGE3rM/YKRc1YKBu8NfPvk4wJjzQ8+BlhD6A2UxwAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:4},h={src:"/scum-v-bringup/_next/static/media/2023-08-18T07-37-34-540Z.a8186bce.png",height:692,width:1439,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAAAAACWpiEsAAAAJklEQVR42gVAQQ4AIAji/49ttSkgXhrmUawEvs3WDHyKko2U1Nz9KjIe0lEVS+wAAAAASUVORK5CYII=",blurWidth:8,blurHeight:4},o={src:"/scum-v-bringup/_next/static/media/lrwpan_baseband.f69dc0ca.png",height:682,width:1227,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAAAAACWpiEsAAAAJklEQVR42gVAhw0AMAji/3M7TBXEBu5dLQ/IE3FfQVwvs4RxUPJ8MqkfSB093uoAAAAASUVORK5CYII=",blurWidth:8,blurHeight:4},c={src:"/scum-v-bringup/_next/static/media/lrwpan_crc_diagram.1c61bf97.png",height:185,width:832,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAAAAABA/8IxAAAAHElEQVR42mP49/PLl2/ff/5i+Prl46cPn95/BQCKyg9SJDmCawAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:2},x={src:"/scum-v-bringup/_next/static/media/ble_baseband.a769fa8f.png",height:295,width:1219,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAAAAABA/8IxAAAAGklEQVR42gWAMQ0AAAzC8C+4o1xLYLQzVg59i28Pf3QNldYAAAAASUVORK5CYII=",blurWidth:8,blurHeight:2},j={src:"/scum-v-bringup/_next/static/media/ble_ppdu_schematic.8b9500ac.png",height:164,width:1237,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABCAYAAADjAO9DAAAAKElEQVR4nGN8//79f2YWFob/f/4wsH37xsAAYvPxMfz88YOBjY2NAQD/fgzgG6uB8QAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:1},u={src:"/scum-v-bringup/_next/static/media/ble_crc_diagram.4aa0947f.png",height:267,width:2007,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABCAYAAADjAO9DAAAAHklEQVR4nGP8/v3H/3///zEwAuF/IATRMPDv3z8GAPaLC97Cynj6AAAAAElFTkSuQmCC",blurWidth:8,blurHeight:1},m={src:"/scum-v-bringup/_next/static/media/whitening_diagram.52215cb4.png",height:220,width:806,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAYAAABllJ3tAAAAL0lEQVR4nD3GQQ4AEBADwDbr/+9VNluCmNMwMz1mgiTsQlUhop17n5JsPD+X1LEAaiMbs7PU2GsAAAAASUVORK5CYII=",blurWidth:8,blurHeight:2},g={src:"/scum-v-bringup/_next/static/media/modem_tx_schematic.ce7f96bc.png",height:975,width:1534,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAAAAABd+vKJAAAAMklEQVR42hXGQQoAIAgEQP//zjpFIVioWW04pyGE9iJ4lKl8kOEqN8hUfXQLgq89m+MDYa8mfU9rqPMAAAAASUVORK5CYII=",blurWidth:8,blurHeight:5},p={src:"/scum-v-bringup/_next/static/media/modem_rx_schematic.5c23ff44.png",height:748,width:1843,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAAAAACLoxGUAAAAI0lEQVR42gVAQQ4AIAji/59tS8kDqA2SzXSD59YLFmZ3MtQfOmEXTPqDZOMAAAAASUVORK5CYII=",blurWidth:8,blurHeight:3},b=i(5956);function f(e){return[{value:"Dual-Mode Baseband-Modem",id:"dual-mode-baseband-modem",depth:2},{value:"Architecture Overview",id:"architecture-overview",depth:3},{value:"Baseband-Modem Frontend",id:"baseband-modem-frontend",depth:3},{value:"Commands and MMIO Registers",id:"commands-and-mmio-registers",depth:4},{value:"List of Commands",id:"list-of-commands",depth:4},{value:"Configuring Modem LUTs",id:"configuring-modem-luts",depth:4},{value:"Configuring the FIR filter coefficients",id:"configuring-the-fir-filter-coefficients",depth:4},{value:"Interrupts",id:"interrupts",depth:3},{value:"IEEE 802.15.4 LR-WPAN Baseband",id:"ieee-802154-lr-wpan-baseband",depth:2},{value:"Bluetooth Low Energy (BLE) Baseband",id:"bluetooth-low-energy-ble-baseband",depth:2},{value:"Whitening",id:"whitening",depth:3},{value:"Unified FSK Modem",id:"unified-fsk-modem",depth:2},{value:"TX Chain",id:"tx-chain",depth:3},{value:"RX Chain",id:"rx-chain",depth:3},{value:"Image Rejection",id:"image-rejection",depth:4},{value:"FSK Demodulation",id:"fsk-demodulation",depth:4},{value:"Clock and Data Recovery (CDR)",id:"clock-and-data-recovery-cdr",depth:4},{value:"Automatic Gain Control (AGC)",id:"automatic-gain-control-agc",depth:4},{value:"DC Offset Compensation (DCO)",id:"dc-offset-compensation-dco",depth:4},{value:"Example Radio Front-End (RFE)",id:"example-radio-front-end-rfe",depth:2}]}var A=(0,r.c)(function(e){let{toc:t=f(e)}=e,i={a:"a",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h1,{children:"Digital Baseband-Modem"}),"\n",(0,n.jsx)(i.h2,{id:t[0].id,children:t[0].value}),"\n",(0,n.jsx)(i.p,{children:"The Dual-Mode Baseband-Modem (BM) is responsible for handling the transmission and reception of both Bluetooth LE and IEEE 802.15.4 packets. For Bluetooth Low Energy, the BM handles Bluetooth Low Energy 1M Uncoded Link Layer Packets. For IEEE 802.15.4, the BM handles packets transmitted according to the PHY standard for the O-QPSK modulation in the 2.4 GHz band. Additionally the BM exposes an interface for the CPU to read/write various information (e.g. tuning bits) to the analog RF."}),"\n",(0,n.jsx)(i.p,{children:"There are two primary sub-components in the Baseband-Modem, the Baseband, and the Modem. The baseband is responsible for the bit-stream processing of incoming and outgoing packets. The modem is responsible for modulation on the TX side, and digital image rejection and demodulation on the RX side."}),"\n",(0,n.jsx)(i.h3,{id:t[1].id,children:t[1].value}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Baseband-Modem TX Architecture",placeholder:"blur",src:a})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Baseband-Modem RX Architecture",placeholder:"blur",src:l})}),"\n",(0,n.jsx)(i.h3,{id:t[2].id,children:t[2].value}),"\n",(0,n.jsx)(i.h4,{id:t[3].id,children:t[3].value}),"\n",(0,n.jsx)(i.p,{children:"The baseband-modem (BM) block contains a set of memory mapped registers used for passing commands to the BM, tuning analog RF components, and making BM status visible to the CPU. The address map is shown below. Note that the addresses are relative to the BM’s base attachment address. For example, if the BM is attached at 0x8000, then the address of 0x04 corresponds to 0x8004."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"ADDR"}),(0,n.jsx)(i.th,{children:"DATA"}),(0,n.jsx)(i.th,{children:"Size (bits)"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x00"}),(0,n.jsx)(i.td,{children:"Instruction"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"Instruction received from processor. Contains 4 bits of primary instruction, 4 bits of secondary instruction, then 24 bits of data."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x04"}),(0,n.jsx)(i.td,{children:"Additional Data"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"Additional data to write. Set data before writing instructions when applicable."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x08"}),(0,n.jsx)(i.td,{children:"Status 0"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsxs)(i.td,{children:["[2:0] Assembler State",(0,n.jsx)("br",{}),"[5:3] Disassembler State",(0,n.jsx)("br",{}),"[7:6] TX State",(0,n.jsx)("br",{}),"[10:8] RX Controller State",(0,n.jsx)("br",{}),"[12:11] TX Controller State",(0,n.jsx)("br",{}),"[15:13] Controller State",(0,n.jsx)("br",{}),"[23:16] ADC I data",(0,n.jsx)("br",{}),"[31:24] ADC Q data"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x0C"}),(0,n.jsx)(i.td,{children:"Status 1"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsxs)(i.td,{children:["[5:0] Modulation LUT index",(0,n.jsx)("br",{}),"[10:6] I AGC LUT index",(0,n.jsx)("br",{}),"[15:11] I DCOC LUT index",(0,n.jsx)("br",{}),"[20:16] Q AGC LUT index",(0,n.jsx)("br",{}),"[25:21] Q DCOC LUT index"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x10"}),(0,n.jsx)(i.td,{children:"Status 2"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"[31:0] BLE CDR bit count"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x14"}),(0,n.jsx)(i.td,{children:"Status 3"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"[31:0] LRWPAN CDR bit count"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x18"}),(0,n.jsx)(i.td,{children:"Status 4"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"[31:0] LO/32 counter"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x1C"}),(0,n.jsx)(i.td,{children:"General trim 0"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"General trim bits (N/C)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x1D"}),(0,n.jsx)(i.td,{children:"General trim 1"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"[0] LO/32 input (external, not implemented)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x1E"}),(0,n.jsx)(i.td,{children:"General trim 2"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"General trim bits (N/C)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x1F"}),(0,n.jsx)(i.td,{children:"General trim 3"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"General trim bits (N/C)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x20"}),(0,n.jsx)(i.td,{children:"General trim 4"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"General trim bits (N/C)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x21"}),(0,n.jsx)(i.td,{children:"General trim 5"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"General trim bits (N/C)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x22"}),(0,n.jsx)(i.td,{children:"General trim 6"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"General trim bits (N/C)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x23"}),(0,n.jsx)(i.td,{children:"General trim 7"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Debug Enable (0 = debug enable)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x24"}),(0,n.jsx)(i.td,{children:"I VGA gain control"}),(0,n.jsx)(i.td,{children:"10"}),(0,n.jsx)(i.td,{children:"Manual VGA value if not using I AGC"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x26"}),(0,n.jsx)(i.td,{children:"I VGA attenuation reset"}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"reset the I AGC"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x27"}),(0,n.jsx)(i.td,{children:"I VGA attenuation useAGC"}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"use I AGC (manual VGA value if not)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x28"}),(0,n.jsx)(i.td,{children:"I VGA attenuation sample window"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I AGC sample window"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x29"}),(0,n.jsx)(i.td,{children:"I VGA attenuation ideal peak to peak"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I AGC ideal peak to peak"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x2A"}),(0,n.jsx)(i.td,{children:"I VGA tolerance peak to peak"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I AGC peak to peak tolerance"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x2B"}),(0,n.jsx)(i.td,{children:"I BPF CHP 0 & 1"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x2C"}),(0,n.jsx)(i.td,{children:"I BPF CHP 2 & 3"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x2D"}),(0,n.jsx)(i.td,{children:"I BPF CHP 4 & 5"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x2E"}),(0,n.jsx)(i.td,{children:"I BPF CLP 0 & 1"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x2F"}),(0,n.jsx)(i.td,{children:"I BPF CLP 2"}),(0,n.jsx)(i.td,{children:"4"}),(0,n.jsx)(i.td,{children:"I bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x30"}),(0,n.jsx)(i.td,{children:"Q VGA gain control"}),(0,n.jsx)(i.td,{children:"10"}),(0,n.jsx)(i.td,{children:"Manual VGA value if not using Q AGC"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x32"}),(0,n.jsx)(i.td,{children:"Q VGA attenuation reset"}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"reset the Q AGC"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x33"}),(0,n.jsx)(i.td,{children:"Q VGA attenuation useAGC"}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"use Q AGC (manual VGA value if not)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x34"}),(0,n.jsx)(i.td,{children:"Q VGA attenuation sample window"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q AGC sample window"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x35"}),(0,n.jsx)(i.td,{children:"Q VGA attenuation ideal peak to peak"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q AGC ideal peak to peak"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x36"}),(0,n.jsx)(i.td,{children:"Q VGA tolerance peak to peak"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q AGC peak to peak tolerance"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x37"}),(0,n.jsx)(i.td,{children:"Q BPF CHP 0 & 1"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x38"}),(0,n.jsx)(i.td,{children:"Q BPF CHP 2 & 3"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x39"}),(0,n.jsx)(i.td,{children:"Q BPF CHP 4 & 5"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x3A"}),(0,n.jsx)(i.td,{children:"Q BPF CLP 0 & 1"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x3B"}),(0,n.jsx)(i.td,{children:"Q BPF CLP 2"}),(0,n.jsx)(i.td,{children:"4"}),(0,n.jsx)(i.td,{children:"Q bandpass filter tuning"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x3C"}),(0,n.jsx)(i.td,{children:"I DCO use"}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"toggle using I DCO"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x3D"}),(0,n.jsx)(i.td,{children:"I DCO reset"}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"reset the I DCO"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x3E"}),(0,n.jsx)(i.td,{children:"I DCO gain"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"set gain for I DCO (unsigned FixedPoint w/ 2 bit binary point)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x3F"}),(0,n.jsx)(i.td,{children:"Q DCO use"}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"toggle using Q DCO"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x40"}),(0,n.jsx)(i.td,{children:"Q DCO reset"}),(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"reset the Q DCO"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x41"}),(0,n.jsx)(i.td,{children:"Q DCO gain"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"set gain for Q DCO (unsigned FixedPoint w/ 2 bit binary point)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x42"}),(0,n.jsx)(i.td,{children:"DCOC tuning 1"}),(0,n.jsx)(i.td,{children:"6"}),(0,n.jsx)(i.td,{children:"Manual I current DAC for stage 2 VGA value if not using I DCO"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x43"}),(0,n.jsx)(i.td,{children:"DCOC tuning 2"}),(0,n.jsx)(i.td,{children:"6"}),(0,n.jsx)(i.td,{children:"Manual Q current DAC for stage 2 VGA value if not using Q DCO"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x46"}),(0,n.jsx)(i.td,{children:"MUX debug in"}),(0,n.jsx)(i.td,{children:"10"}),(0,n.jsx)(i.td,{children:"Debug configuration, input"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x48"}),(0,n.jsx)(i.td,{children:"MUX debug out"}),(0,n.jsx)(i.td,{children:"10"}),(0,n.jsx)(i.td,{children:"Debug configuration, output"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x4A"}),(0,n.jsx)(i.td,{children:"Enable RX I"}),(0,n.jsx)(i.td,{children:"5"}),(0,n.jsx)(i.td,{children:"Manual enable RX I values {3’b0, mix, buf, vga_s1, vga_s2, bpf}"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x4B"}),(0,n.jsx)(i.td,{children:"Enable RX Q"}),(0,n.jsx)(i.td,{children:"5"}),(0,n.jsx)(i.td,{children:"Manual enable RX Q values {3’b0, mix, buf, vga_s1, vga_s2, bpf}"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x4C"}),(0,n.jsx)(i.td,{children:"Enable VCO LO"}),(0,n.jsx)(i.td,{children:"2"}),(0,n.jsx)(i.td,{children:"Manual enable VCO LO {6’b0, vco_lo, lna}"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x50"}),(0,n.jsx)(i.td,{children:"LUT command"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"LUT set instruction [3:0] LUT ID [9:4] address (index) [31:10] value"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x54"}),(0,n.jsx)(i.td,{children:"RX error message"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"Interrupt message, RX error message"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x58"}),(0,n.jsx)(i.td,{children:"RX finish message"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"Interrupt message, RX finish message"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x5C"}),(0,n.jsx)(i.td,{children:"TX error message"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"Interrupt message, TX error message"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x60"}),(0,n.jsx)(i.td,{children:"FIR command"}),(0,n.jsx)(i.td,{children:"32"}),(0,n.jsx)(i.td,{children:"FIR filter reprogramming instruction, [3:0] FIR ID [9:4] coefficient (index) [31:10] value"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x64"}),(0,n.jsx)(i.td,{children:"I VGA attenuation gain increase"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I AGC gain increase step size (by LUT index)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x65"}),(0,n.jsx)(i.td,{children:"I VGA attenuation gain decrease"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"I AGC gain decrease step size (by LUT index)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x66"}),(0,n.jsx)(i.td,{children:"Q VGA attenuation gain increase"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q AGC gain increase step size (by LUT index)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x67"}),(0,n.jsx)(i.td,{children:"Q VGA attenuation gain decrease"}),(0,n.jsx)(i.td,{children:"8"}),(0,n.jsx)(i.td,{children:"Q AGC gain decrease step size (by LUT index)"})]})]})]}),"\n",(0,n.jsx)(b.U,{type:"warning",children:(0,n.jsx)(i.p,{children:"The processor should always write to the additional data register prior to writing to the instruction register for a given command. Writing to the register at 0x00 is the trigger for the BM to execute a given command."})}),"\n",(0,n.jsx)(i.p,{children:"In order to pass commands to the BM, two 32-bit registers at addresses 0x00 and 0x04 are utilized. The register at 0x04 contains the additional data field for a given command while the register at 0x00 contains the instruction."}),"\n",(0,n.jsx)(i.p,{children:"The format for a BM instruction is:"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Bits"}),(0,n.jsx)(i.th,{children:"31-8"}),(0,n.jsx)(i.th,{children:"7-4"}),(0,n.jsx)(i.th,{children:"3-0"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Field"}),(0,n.jsx)(i.td,{children:"Data"}),(0,n.jsx)(i.td,{children:"Instruction 2"}),(0,n.jsx)(i.td,{children:"Instruction 1"})]})})]}),"\n",(0,n.jsx)(i.h4,{id:t[4].id,children:t[4].value}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Configure Command"})}),"\n",(0,n.jsx)(i.p,{children:"Configure baseband constants. The constant is selected using the instruction 2 field and set to the value specified in the additional data field. In the case that the secondary instruction is set to CONFIG_LUT, reference the LUT addresses provided in the explanations below."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Data"}),(0,n.jsx)(i.th,{children:"Instruction 2"}),(0,n.jsx)(i.th,{children:"Instruction 1"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"X unless CONFIG_LUT, then LUT address"}),(0,n.jsx)(i.td,{children:"See table"}),(0,n.jsx)(i.td,{children:"0"})]})})]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Additional Data"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"Value for the constant to be set to"})]})})]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Instruction 2"}),(0,n.jsx)(i.th,{children:"Name"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x0"}),(0,n.jsx)(i.td,{children:"CONFIG_RADIO_MODE"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x1"}),(0,n.jsx)(i.td,{children:"CONFIG_CRC_SEED"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x2"}),(0,n.jsx)(i.td,{children:"CONFIG_ACCESS_ADDRESS"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x3"}),(0,n.jsx)(i.td,{children:"CONFIG_SHR"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x4"}),(0,n.jsx)(i.td,{children:"CONFIG_BLE_CHANNEL_INDEX"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0x5"}),(0,n.jsx)(i.td,{children:"CONFIG_LRWPAN_CHANNEL_INDEX"})]})]})]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Configuration instruction descriptions"})}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(0x0) CONFIG_RADIO_MODE:"}),"\nSpecify the following in the Additional Data register (0x04) prior to issuing the instruction"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"0: Set the radio transceiver mode to Bluetooth Low Energy"}),"\n",(0,n.jsx)(i.li,{children:"1: Set the radio transceiver mode to IEEE 802.15.4 LR-WPAN"}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Valid in any radio mode."}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(0x1) CONFIG_CRC_SEED:"}),"\nSet the CRC (cyclic redundancy check) seed for the BLE and LR-WPAN CRC circuits to the value in the Additional Data register (0x04). This value changes for BLE and should be 0 for LR-WPAN"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(0x2) CONFIG_ACCESS_ADDRESS:"}),"\nSet the BLE Access Address for the BLE uncoded packet. This value must be provided by the CPU. More information may be found in the BLE Baseband section."]}),"\n",(0,n.jsx)(b.U,{type:"info",children:(0,n.jsx)(i.p,{children:"An access address of 0xFFFFFFF6 disables whitening of transmitted BLE packets"})}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(0x3) CONFIG_SHR:"}),"\nSet the LRWPAN SHR to match with for receiving a LRWPAN packet. This value must be provided by the CPU. According to 802.15.4 spec, it should be a fixed value of 0xA700 (only 2 bytes are matched due to lower hardware cost), but is programmable for flexibility."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(0x4) CONFIG_BLE_CHANNEL_INDEX:"}),"\nValues for the channel index can range from 0 to 39, corresponding to BLE channel frequencies beginning at 2402 MHz until 2480 MHz. It is critical to note that the channel index from 0 to 39 is a direct mapping to channel frequencies - NOT the BLE channel numbering scheme that considers advertising channels separately. For example, setting CONFIG_BLE_CHANNEL_INDEX to 0 will result in a transmission with center frequency at 2402 MHz. This corresponds to BLE channel 37. ",(0,n.jsx)(i.a,{href:"https://www.rfwireless-world.com/Terminology/BLE-Advertising-channels-and-Data-channels-list.html",children:"More information"})]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"(0x5) CONFIG_LRWPAN_CHANNEL_INDEX:"}),"\nValues for the channel index can range from 0 to 15, corresponding to LR-WPAN channel frequencies beginning at 2405 MHz until 2480 MHz."]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Send Command"})}),"\n",(0,n.jsx)(i.p,{children:"Transmit a specified number of PDU header and data bytes. Bytes are retrieved by the BM by loading them from the specified address."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Data"}),(0,n.jsx)(i.th,{children:"Instruction 2"}),(0,n.jsx)(i.th,{children:"Instruction 1"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"Number of bytes"}),(0,n.jsx)(i.td,{children:"X"}),(0,n.jsx)(i.td,{children:"1"})]})})]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Additional Data"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"Load address"})]})})]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Receive Enter Command"})}),"\n",(0,n.jsx)(i.p,{children:"Place the device into receive mode. If a message is picked up, it will be stored starting at the specified address address."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Data"}),(0,n.jsx)(i.th,{children:"Instruction 2"}),(0,n.jsx)(i.th,{children:"Instruction 1"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"X"}),(0,n.jsx)(i.td,{children:"X"}),(0,n.jsx)(i.td,{children:"2"})]})})]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Additional Data"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"Storage address"})]})})]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Receive Exit Command"})}),"\n",(0,n.jsx)(i.p,{children:"Exit the device from receive mode. This command will succeed as long as the device has not yet matched an instruction preamble."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Data"}),(0,n.jsx)(i.th,{children:"Instruction 2"}),(0,n.jsx)(i.th,{children:"Instruction 1"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"X"}),(0,n.jsx)(i.td,{children:"X"}),(0,n.jsx)(i.td,{children:"3"})]})})]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Additional Data"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"X"})]})})]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Debug Command"})}),"\n",(0,n.jsx)(i.p,{children:"Turns on both the TX and RX paths according to the specified loopback mask before passing the specified number of PDU bytes in a loop. For simplicity the return data is stored at <load address + total bytes> rounded to the next byte aligned address. The loopback mask is used to determine at which point the data should be revered and sent back towards the CC."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Data"}),(0,n.jsx)(i.th,{children:"Instruction 2"}),(0,n.jsx)(i.th,{children:"Instruction 1"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"Total bytes to send"}),(0,n.jsx)(i.td,{children:"Loopback mask"}),(0,n.jsx)(i.td,{children:"15"})]})})]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Field"}),(0,n.jsx)(i.th,{children:"Additional Data"})]})}),(0,n.jsx)(i.tbody,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Value"}),(0,n.jsx)(i.td,{children:"Load address and base for store address calculation"})]})})]}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Loopback Mask"}),(0,n.jsx)(i.th,{children:"Loopback Point"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0b0001 (0x1)"}),(0,n.jsx)(i.td,{children:"Empty"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0b0010 (0x2)"}),(0,n.jsx)(i.td,{children:"In the modem, loop the FSKTX output back in to the CDR in FSKRX"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0b0100 (0x4)"}),(0,n.jsx)(i.td,{children:"Empty"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0b1000 (0x8)"}),(0,n.jsx)(i.td,{children:"Empty"})]})]})]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"Loopback diagram:"})," Note that the FSKRX module handles loopback logic and directs the output of MSKTX & GFSK TX modules to respective CDR blocks"]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Loopback Diagram",placeholder:"blur",src:h})}),"\n",(0,n.jsx)(i.h4,{id:t[5].id,children:t[5].value}),"\n",(0,n.jsx)(i.p,{children:"The modem LUTs can be configured using the LUT command register in the MMIO map enumerated above (register offset 0x50)."}),"\n",(0,n.jsx)(i.p,{children:"LUT IDs are defined as follows:"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x0 - VCO_MOD:"}),"\n64-entry, 8-bit valued LUT that is sampled to produce frequency deviations from the center frequency. This LUT must be reloaded on each channel and mode change. 0 indicates the largest negative frequency deviation, 63 indicates the largest positive deviation, and 31 indicates no frequency deviation. Note that 0/63 should be +/-250kHz for BLE and +/-500kHz for LR-WPAN."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x1 - VCO_CT_BLE:"}),"\n40-entry LUT sampled with BLE channel index to produce coarse and medium tuning bits to drive the VCO to the center frequency of the BLE channel index selected. Does not apply when in LR-WPAN radio mode."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x2 - VCO_CT_LRWPAN:"}),"\n16-entry LUT that is sampled with the LR-WPAN channel index to produce the coarse and medium tuning bits to drive the VCO to the center frequency of the LR-WPAN channel index selected. Does not apply when in BLE radio mode."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x3 - AGC_I:"}),"\n64-entry LUT that is sampled to drive the VGA attenuation gain for the I channel VGA. Only the lower 32 entries are used."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x4 - AGC_Q:"}),"\n64-entry LUT that is sampled to drive the VGA attenuation gain for the Q channel VGA. Only the lower 32 entries are used."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x5 - DCO_I:"}),"\n64-entry LUT that is sampled to drive the current DAC for the I channel stage 2 VGA. Only the lower 32 entries are used."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x6 - DCO_Q:"}),"\n64-entry LUT that is sampled to drive the current DAC for the Q channel stage 2 VGA. Only the lower 32 entries are used."]}),"\n",(0,n.jsx)(i.h4,{id:t[6].id,children:t[6].value}),"\n",(0,n.jsx)(i.p,{children:"The FIR filter coefficients can be configured using the FIR command register in the MMIO map enumerated above (register offset 0x60)."}),"\n",(0,n.jsx)(i.p,{children:"FIR IDs are defined as follows:"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x0 - NONE:"}),"\nReserved"]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x1 - TX_GAUSSIAN:"}),"\n24-entry, 8-bit FixedPoint (2-bit fractional component) filter for BLE GFSK. Only 16 coefficients are used. Note the filter was designed to run at 8MHz (length = 2*cycles/bit) but there’s a bug in the implementation. The short-term fix to get it working was to double the coefficients."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x2 - RX_HILBERT_I:"}),"\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for image rejection."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x3 - RX_HILBERT_Q:"}),"\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for image rejection. The output of the I and Q filters are summed to form the image rejected signal suitable for FSK demodulation."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x4 - RX_MATCH_SIN_F0:"}),"\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for matched filter for binary 0. Two templates (filters) are used to account for phase shift. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x5 - RX_MATCH_COS_F0:"}),"\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for matched filter for binary 0. Two templates (filters) are used to account for phase shift. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x6 - RX_MATCH_SIN_F1:"}),"\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for matched filter for binary 1. Two templates (filters) are used to account for phase shift. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x7 - RX_MATCH_COS_F1:"}),"\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for matched filter for binary 1. Two templates (filters) are used to account for phase shift. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"0x8 - RX_LPF:"}),"\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for bitrate filter of the matched filter output. Two filters with the same coefficients are used, one for 0s and another for 1s. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately."]}),"\n",(0,n.jsx)(i.h3,{id:t[7].id,children:t[7].value}),"\n",(0,n.jsx)(i.p,{children:"The Baseband-Modem provides five interrupts as outputs from the Baseband Frontend. These interrupts provide the CPU with triggers for events from the transceiver module. The interrupts are described in the table below:"}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Baseband-Modem interrupt table"})}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Interrupt Index"}),(0,n.jsx)(i.th,{children:"Name"}),(0,n.jsx)(i.th,{children:"Description"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"0"}),(0,n.jsx)(i.td,{children:"RX_ERROR"}),(0,n.jsx)(i.td,{children:"Triggers on recognition of an error while the BM is in RX state. The MMIO register 0x54 will be populated with an RX_ERROR_MESSAGE. Presently not implemented."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"1"}),(0,n.jsx)(i.td,{children:"RX_START"}),(0,n.jsx)(i.td,{children:"Triggers when the baseband disassembler/correlator enters the busy state. Denotes that a packet has been received and demodulated, but has not yet been disassembled."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"2"}),(0,n.jsx)(i.td,{children:"RX_FINISH"}),(0,n.jsx)(i.td,{children:"Triggers when the disassembler has completed processing an incoming message. Populates the MMIO register RX_FINISH_MESSAGE at 0x58 with the length of the message."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"3"}),(0,n.jsx)(i.td,{children:"TX_ERROR"}),(0,n.jsx)(i.td,{children:"Triggers on recognition of an error while the BM is in TX state. The MMIO register 0x5C will be populated with an TX_ERROR_MESSAGE. Presently not implemented."})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"4"}),(0,n.jsx)(i.td,{children:"TX_FINISH"}),(0,n.jsx)(i.td,{children:"Triggers when the modem has completed transmission of all bytes in the provided message. The DMA read response bytes must match the number of bytes specified in the Send Command for this interrupt to fire."})]})]})]}),"\n",(0,n.jsx)(i.h2,{id:t[8].id,children:t[8].value}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Baseband modulation/demodulation diagram"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Baseband modulation/demodulation diagram",placeholder:"blur",src:o})}),"\n",(0,n.jsx)(i.p,{children:"The LR-WPAN baseband transmission chain involves DMA packet disassembly, LR-WPAN packet assembly, CRC generation, bit-to-symbol translation, and symbol-to-chip translation before the final chip stream is provided to the modem for modulation. The packet is assembled according to the IEEE 802.15.4 (LR-WPAN) PPDU schematic (shown below)."}),"\n",(0,n.jsx)(i.p,{children:"It is important to note the rates at each stage of the baseband TX chain. The standard calls for a 250 kb/s bitrate corresponding to packet assembly/packet disassembly. Following bit-to-symbol translation, the symbol rate becomes 62.5 ksym/s (where 4 bits specifies 1 symbol). Following symbol-to-chip translation, the chip rate now matches the LR-WPAN nominal baseband frequency of 2 MHz frequency or 2 Mchip/s (where 1 symbol specifies 32 chips). The inverse applies for the RX chain."}),"\n",(0,n.jsx)(i.p,{children:"During packet assembly, a frame check sequence is calculated as a 16-bit ITU-T CRC."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"CRC calculation diagram"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"CRC calculation diagram",placeholder:"blur",src:c})}),"\n",(0,n.jsx)(i.p,{children:"The algorithm for the CRC begins by setting all remainder registers, r0…r15, to zero. Next, we start from the LSB and shift the MHR and payload into the divider. The FCS is then the remainder register after the last bit of the data is shifted in. Lastly, the FCS is appended to the data field so that register r0 is transmitted first."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"IEEE 802.15.4 PPDU Schematic"})}),"\n",(0,n.jsx)(i.p,{children:"The frame check sequence (FCS) is appended to the end of the PPDU as the MAC footer (MFR) in the diagram above. If the result of CRC checking is false, the [flag] is set to high, before triggering a RX_ERROR message."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"PSDU Schematic"})}),"\n",(0,n.jsx)(i.p,{children:"The preamble for 15.4 is a 32-bit sequence of all zeros. The SFD is loosely analogous to the Access-Address (AA) of the BLE Baseband in that they both uniquely identify the start of the packet for the protocol used."}),"\n",(0,n.jsx)(i.h2,{id:t[9].id,children:t[9].value}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"BLE baseband and modulation/demodulation diagram"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"BLE baseband and modulation/demodulation diagram",placeholder:"blur",src:x})}),"\n",(0,n.jsx)(i.p,{children:"Below is the BLE Uncoded Packet format. All elements of the packet either are or depend on data that the CPU must set (which is taken care of by the SW implementation of the Link Layer). These values are communicated to the packet assembler and disassembler through the controller via the command system over MMIO."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"BLE PPDU Schematic"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"BLE PPDU Schematic",placeholder:"blur",src:j})}),"\n",(0,n.jsx)(i.p,{children:"The Preamble is an alternating series of 1s and 0s that depends on the LSB of the Access-Address (AA). The CPU need not provide any additional control signals for this part of the packet."}),"\n",(0,n.jsx)(i.p,{children:"The Access-Address is a special value set by the SW Link Layer that determines whether a packet is valid or not. This value must be provided by the CPU and depends on past communications or may be set to some default value."}),"\n",(0,n.jsx)(i.p,{children:"The PDU is the already encrypted content of the packet, the CPU must provide this in its entirety. Through the DMA controller, the packet assembler will retrieve this from main memory. The packet disassembler will deliver a PDU to the main memory once one is received."}),"\n",(0,n.jsx)(i.p,{children:"The CRC (cyclic redundancy check) is derived from the Link Layer state (which must be provided by the CPU via MMIO register). In the receive chain, if the calculated CRC does not match the CRC found in the PDU, the [flag] is set to high."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"BLE CRC functional schematic"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"BLE CRC functional schematic",placeholder:"blur",src:u})}),"\n",(0,n.jsx)(i.h3,{id:t[10].id,children:t[10].value}),"\n",(0,n.jsx)(i.p,{children:"In order to avoid long continuous sequences of 1s and 0s in the transmitted data, the entire packet goes through a process known as whitening."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Whitening diagram"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Whitening diagram",placeholder:"blur",src:m})}),"\n",(0,n.jsx)(i.p,{children:"Outgoing data on the TX chain is whitened and incoming data is also “de-whitened”"}),"\n",(0,n.jsx)(i.h2,{id:t[11].id,children:t[11].value}),"\n",(0,n.jsx)(i.p,{children:"The modem sits between the digital baseband and the ADCs / DAC to analog RF. It is responsible for performing demodulation and modulation and clock and data recovery at a rate of 1Mbps for BLE or 2Mchip/s for LR-WPAN. Each cycle, the digital baseband either receives a new bit from the demodulator, or provides a new bit for transmission to the modulator."}),"\n",(0,n.jsx)(i.h3,{id:t[12].id,children:t[12].value}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Modem TX chain schematic"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Modem TX chain schematic",placeholder:"blur",src:g})}),"\n",(0,n.jsx)(i.p,{children:"The digital baseband bit-stream process outputs individual bits into a FIFO that will be consumed by the modem for use in modulation. For BLE transmissions, the bitstream is modulated using Gaussian frequency shift keying (GFSK). The modulator modulates the outgoing bits using at a rate of 1Msym/s, with a modulation index of 0.5. For LR-WPAN transmissions, the chipstream directly drives the modulation LUT. The output of the modulation LUT is an 8-bit unsigned integer value that indicates the FSK modulation away from the maximum frequency at that channel tuning."}),"\n",(0,n.jsx)(i.p,{children:"The 6-bit FSK modulation output, in conjunction with a 6 bit channel select value, are used to address into the Modulation LUT to retrieve input values for the VCO LO based on the channel index and modulation frequency offset. These decoding LUTs provide 8-bit values for LO coarse tuning, LO FSK, and the PLL division."}),"\n",(0,n.jsx)(i.h3,{id:t[13].id,children:t[13].value}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.strong,{children:"Modem RX chain schematic"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Modem RX chain schematic",placeholder:"blur",src:p})}),"\n",(0,n.jsx)(i.p,{children:"After mixing, the analog I and Q signals go through ADCs to produce 8 bit output values. The ADCs are clocked on the negative edge of the digital system clock. On the falling system clock edge, the ADCs sample and latch the signals coming from analog RF. These sampled 8-bit values are then captured by rising-edge triggered flip-flops at the analog-digital boundary of the RX chain."}),"\n",(0,n.jsx)(i.h4,{id:t[14].id,children:t[14].value}),"\n",(0,n.jsx)(i.p,{children:"After mixing with the LO and being sampled by the I/Q ADCs, the Q signal for the signal (F_LO+F_IF) ends up +90\xb0 shifted from I while the image (F_LO-F_IF) ends up -90\xb0 shifted from I. A Hilbert filter shifts positive frequencies by +90\xb0 and negative frequencies by -90\xb0. By applying it to the I signal and adding to the Q signal, this causes constructive interference for the desired signal and destructive interference for the image, heavily attenuating it. Note these filters are fully configurable (up to their maximum length) if needed."}),"\n",(0,n.jsx)(i.h4,{id:t[15].id,children:t[15].value}),"\n",(0,n.jsx)(i.p,{children:"After image rejection, the matched filters (the optimal non-coherent demodulator!) and envelope detection serve to discriminate between positive and negative frequency deviations. A matched filter performs a convolution of the input signal with a “template” which is simply samples of the desired frequency up to the length of a bit/chip period. Due to phase shift, we must have sine and cosine templates and sum the two. Since the filters generate high frequency noise, we perform “envelope detection” after the matched filters to remove it and get a clean signal giving the magnitude of the match. Comparing the magnitude of each gives us the decision for the deviation."}),"\n",(0,n.jsx)(i.p,{children:"For an ADC clock of 32MHz, we need a 32-length filter for BLE and 16-length filter for LR-WPAN. For an IF of 2MHz, we need templates of 1.75MHz and 2.25MHz for BLE and 1.5MHz and 2.5MHz for LR-WPAN."}),"\n",(0,n.jsx)(i.h4,{id:t[16].id,children:t[16].value}),"\n",(0,n.jsx)(i.p,{children:"After FSK demodulation, we have an oversampled bitstream which must downsample to the appropriate bitrate. The goal of the CDR is to align the sampling window with the phase of the incoming bitstream."}),"\n",(0,n.jsx)(i.p,{children:"Our design has 3 integrators - early, present, late - which each look at a window (of length equal to the bit period) of the incoming bitstream but are offset from each other by 1 cycle. We then have a counter that decrements every cycle. When the counter hits 0, we return a sampled bit that is the value of the strongest integrator (determined by majority and number of 1s and 0s). We then reset the counter to a value that will cause the winning integrator in the next bit period to be closer to the present integrator (either by extending or shortening the amount of time to the next sample time)."}),"\n",(0,n.jsx)(i.h4,{id:t[17].id,children:t[17].value}),"\n",(0,n.jsx)(i.p,{children:"The AGC supports a high dynamic range by keeping the ADCs near saturation. It tracks the minimum and maximum ADC values and increases or decreases the gain based on signal strength. It is recommended to keep the tolerance larger than the gain resolution to prevent oscillation."}),"\n",(0,n.jsx)(i.h4,{id:t[18].id,children:t[18].value}),"\n",(0,n.jsx)(i.p,{children:"The DCO integrates the incoming signal, applies gain, and feeds back into the LUT to calibrate the VGA and remove DC offset."}),"\n",(0,n.jsx)(i.h2,{id:t[19].id,children:t[19].value}),"\n",(0,n.jsx)(i.p,{children:"The example RFE operates in the 2.4G to 2.4835 GHz range, covering 70 1MHz RF channels. The receive chain functions from -70dBm to -10dBm with detailed interference specifications for in-band and out-of-band conditions. It uses a low-IF receiver and direct modulation transmitter architecture."})]})},"/digital-baseband",{filePath:"pages/digital-baseband.mdx",timestamp:1756130132e3,pageMap:d.v,frontMatter:{title:"Digital Baseband-Modem",description:"Dual-Mode Baseband-Modem for Bluetooth LE and IEEE 802.15.4"},title:"Digital Baseband-Modem"},"undefined"==typeof RemoteContent?f:RemoteContent.useTOC)},5956:function(e,t,i){"use strict";i.d(t,{U:function(){return l}});var n=i(5893),r=i(512),d=i(5192);let s={default:"\uD83D\uDCA1",error:"\uD83D\uDEAB",info:(0,n.jsx)(d.AV,{className:"_mt-1"}),warning:"⚠️"},a={default:(0,r.Z)("_border-orange-100 _bg-orange-50 _text-orange-800 dark:_border-orange-400/30 dark:_bg-orange-400/20 dark:_text-orange-300"),error:(0,r.Z)("_border-red-200 _bg-red-100 _text-red-900 dark:_border-red-200/30 dark:_bg-red-900/30 dark:_text-red-200"),info:(0,r.Z)("_border-blue-200 _bg-blue-100 _text-blue-900 dark:_border-blue-200/30 dark:_bg-blue-900/30 dark:_text-blue-200"),warning:(0,r.Z)("_border-yellow-100 _bg-yellow-50 _text-yellow-900 dark:_border-yellow-200/30 dark:_bg-yellow-700/30 dark:_text-yellow-200")};function l({children:e,type:t="default",emoji:i=s[t]}){return(0,n.jsxs)("div",{className:(0,r.Z)("nextra-callout _overflow-x-auto _mt-6 _flex _rounded-lg _border _py-2 ltr:_pr-4 rtl:_pl-4","contrast-more:_border-current contrast-more:dark:_border-current",a[t]),children:[(0,n.jsx)("div",{className:"_select-none _text-xl ltr:_pl-3 ltr:_pr-2 rtl:_pr-3 rtl:_pl-2",style:{fontFamily:'"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"'},children:i}),(0,n.jsx)("div",{className:"_w-full _min-w-0 _leading-7",children:e})]})}},8619:function(e,t,i){"use strict";i.d(t,{v:function(){return n}});let n=[{data:{index:"Home","-- 1":{type:"separator",title:"Bringup"},"hardware-setup":"Hardware Setup","fpga-setup":"FPGA Programming","bootloading-guide":"Bootloading Guide","firmware-development":"Firmware Development","api-reference":"API Reference","-- 2":{type:"separator",title:"SCuM-V24B Chip Specification"},overview:"Overview","digital-core":"Digital Core",oscillators:"Oscillators",radio:"Radio",radar:"Radar","digital-baseband":"Digital Baseband","power-system":"Power System","uv-adc":"\xb5V-Precision ADC","-- 3":{type:"separator",title:"Archive"},archive:"Archive"}},{name:"api-reference",route:"/api-reference",frontMatter:{sidebarTitle:"API Reference"}},{name:"archive",route:"/archive",children:[{data:{"scum-v23":{title:"SCuM-V23",type:"folder"}}},{name:"scum-v23",route:"/archive/scum-v23",children:[{data:{index:{title:"Overview",display:"hidden"},overview:"Overview","digital-core":"Digital Core","encryption-modules":"Encryption",oscillators:"Oscillators",radio:"Radio",radar:"Radar"}},{name:"digital-core",route:"/archive/scum-v23/digital-core",frontMatter:{title:"Digital Core",description:"Digital Core architecture and specifications for SCuM-V23"}},{name:"encryption-modules",route:"/archive/scum-v23/encryption-modules",frontMatter:{title:"Encryption Modules",description:"Cryptographic acceleration modules including ECC, AES, and SHA-256"}},{name:"index",route:"/archive/scum-v23",frontMatter:{title:"SCuM-V23 Specification",description:"Complete specification for the SCuM-V23 system-on-chip"}},{name:"oscillators",route:"/archive/scum-v23/oscillators",frontMatter:{title:"Oscillators",description:"Clock generation and oscillator systems in SCuM-V23"}},{name:"overview",route:"/archive/scum-v23/overview",frontMatter:{title:"Overview",description:"Overview of the SCuM-V23 System-on-Chip"}},{name:"radar",route:"/archive/scum-v23/radar",frontMatter:{title:"94 GHz FMCW Radar Transmitter",description:"Frequency-modulated continuous wave radar transmitter operating at 94 GHz"}},{name:"radio",route:"/archive/scum-v23/radio",frontMatter:{title:"2.4 GHz Transceiver",description:"2.4 GHz radio transceiver architecture and specifications"}}]}]},{name:"bootloading-guide",route:"/bootloading-guide",frontMatter:{sidebarTitle:"Bootloading Guide"}},{name:"digital-baseband",route:"/digital-baseband",frontMatter:{title:"Digital Baseband-Modem",description:"Dual-Mode Baseband-Modem for Bluetooth LE and IEEE 802.15.4"}},{name:"digital-core",route:"/digital-core",frontMatter:{title:"Digital Core",description:"Digital Core architecture and specifications"}},{name:"firmware-development",route:"/firmware-development",frontMatter:{sidebarTitle:"Firmware Development"}},{name:"fpga-setup",route:"/fpga-setup",frontMatter:{sidebarTitle:"Fpga Setup"}},{name:"hardware-setup",route:"/hardware-setup",frontMatter:{sidebarTitle:"Hardware Setup"}},{name:"index",route:"/",frontMatter:{title:"SCuM-V Bringup & Development",description:"Complete toolkit for bringing up and developing with the Single-Chip Micro Mote V"}},{name:"oscillators",route:"/oscillators",frontMatter:{title:"Oscillators",description:"Clock generation and oscillator systems in SCuM-V24B"}},{name:"overview",route:"/overview",frontMatter:{title:"Overview",description:"Overview of the SCuM-V24B System-on-Chip"}},{name:"power-system",route:"/power-system",frontMatter:{title:"Power System",description:"Power management system including switched capacitor converter, LDOs, and reference circuits for SCuM-V24B"}},{name:"radar",route:"/radar",frontMatter:{title:"94 GHz FMCW Radar Transmitter",description:"Frequency-modulated continuous wave radar transmitter operating at 94 GHz"}},{name:"radio",route:"/radio",frontMatter:{title:"2.4 GHz Transceiver",description:"2.4 GHz radio transceiver architecture and specifications"}},{name:"uv-adc",route:"/uv-adc",frontMatter:{title:"UV-Precision Delta-Sigma ADC",description:"High-precision delta-sigma ADC designed for EEG front-end applications for SCuM-V24B"}}]}},function(e){e.O(0,[812,888,774,179],function(){return e(e.s=6441)}),_N_E=e.O()}]);