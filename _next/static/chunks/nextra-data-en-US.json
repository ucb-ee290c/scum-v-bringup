{"/api-reference":{"title":"API Reference","data":{"":"Comprehensive reference for SCuM-V software interfaces and protocols.","python-host-interfaces#Python Host Interfaces":"","tilelink-host-tl_hostpy#TileLink Host (tl_host.py)":"Primary interface for SerialTL communication with SCuM-V.","basic-usage#Basic Usage":"from tl_host import TileLinkHost\n# Initialize connection\ntl = TileLinkHost(port=\"/dev/ttyUSB0\", baud=2000000)\n# Read from address\ndata = tl.read32(address=0x1000)\n# Write to address  \ntl.write32(address=0x1000, data=0xDEADBEEF)\n# Close connection\ntl.close()","class-methods#Class Methods":"class TileLinkHost:\n    def __init__(self, port: str, baud: int = 2000000)\n    def read32(self, address: int) -> int\n    def write32(self, address: int, data: int) -> None\n    def read_burst(self, start_addr: int, length: int) -> List[int]\n    def write_burst(self, start_addr: int, data: List[int]) -> None\n    def close(self) -> None","analog-scan-chain-client-clientpy#Analog Scan Chain Client (client.py)":"Interface for programming the Analog Scan Chain via UART.","basic-usage-1#Basic Usage":"from client import AnalogScanChain\n# Initialize ASC connection\nasc = AnalogScanChain(port=\"/dev/ttyUSB0\", baud=115200)\n# Configure scan chain\nasc.configure_block(block_id=1, config_data=0x12345678)\n# Read status\nstatus = asc.read_status(block_id=1)","protocol-details#Protocol Details":"Parameter\tValue\tBaud Rate\t115200\tData Bits\t8\tParity\tNone\tStop Bits\t1\tFlow Control\tNone","sensor-adc-interface-sensor_adcpy#Sensor ADC Interface (sensor_adc.py)":"High-level interface for sensor ADC operations.\nfrom sensor_adc import SensorADC\n# Initialize ADC\nadc = SensorADC()\n# Configure sampling\nadc.configure(sample_rate=1000, resolution=16)\n# Read sensor data\nvoltage = adc.read_voltage(channel=0)\ntemperature = adc.read_temperature()","risc-v-firmware-apis#RISC-V Firmware APIs":"","hardware-abstraction-layer#Hardware Abstraction Layer":"","system-initialization#System Initialization":"#include \"scum_hal.h\"\n// Initialize all hardware subsystems\nvoid HAL_init(void);\n// Get monotonic tick counter (microsecond resolution)\nuint64_t HAL_getTick(void);\n// Delay functions\nvoid HAL_delay(uint64_t time_us);           // Delay in microseconds\nvoid HAL_delay_cycles(uint64_t cycles);     // Delay in CPU cycles","gpio-interface#GPIO Interface":"#include \"scum_hal_gpio.h\"\n// GPIO pin enumeration\ntypedef enum {\n    GPIO_PIN_0 = 0b0001U\n} GPIO_Pin;\n// GPIO operations\nvoid HAL_GPIO_init(GPIO_TypeDef *GPIOx, GPIO_Pin pin);\nvoid HAL_GPIO_writePin(GPIO_TypeDef *GPIOx, GPIO_Pin pin, uint8_t value);\nuint8_t HAL_GPIO_readPin(GPIO_TypeDef *GPIOx, GPIO_Pin pin);\n// Example usage:\n// HAL_GPIO_writePin(GPIO0, GPIO_PIN_0, 1);  // Set pin high\n// uint8_t state = HAL_GPIO_readPin(GPIO0, GPIO_PIN_0);  // Read pin","uart-interface#UART Interface":"#include \"scum_hal_uart.h\"\n// UART configuration structures\ntypedef enum {\n    UART_MODE_RX = 0x01,\n    UART_MODE_TX = 0x02,\n    UART_MODE_TX_RX = 0x03,\n} UART_Mode;\ntypedef enum {\n    UART_STOPBITS_1 = 0,\n    UART_STOPBITS_2 = UART_TXCTRL_NSTOP_MSK,\n} UART_StopBits;\ntypedef struct {\n    uint32_t baudrate;\n    UART_Mode mode;\n    UART_StopBits stopbits;\n} UART_InitTypeDef;\n// UART operations\nvoid HAL_UART_init(UART_TypeDef *UARTx, UART_InitTypeDef *UART_init);\nStatus HAL_UART_receive(UART_TypeDef *UARTx, uint8_t *data, uint16_t size, uint32_t timeout);\nStatus HAL_UART_transmit(UART_TypeDef *UARTx, uint8_t *data, uint16_t size, uint32_t timeout);\nvoid HAL_UART_finishTX(UART_TypeDef *UARTx);\n// UART FIFO and interrupt functions\nuint8_t HAL_UART_getRXFIFODepth(UART_TypeDef *UARTx);\nuint8_t HAL_UART_getTXFIFODepth(UART_TypeDef *UARTx);\nvoid HAL_UART_enableRXInterrupt(UART_TypeDef *UARTx, uint16_t fifo_level);\nvoid HAL_UART_disableRXInterrupt(UART_TypeDef *UARTx);","rtc-timer-interface#RTC Timer Interface":"#include \"rtc_timer.h\"\n// Low-level RTC timer functions (register-based)\nint32_t rtc_timer_get_coutner(void);                    // Get current counter value\nvoid rtc_timer_set_task_start(int8_t task_start);       // Start timer task\nvoid rtc_timer_set_task_clear(int8_t task_clear);       // Clear timer task\nvoid rtc_timer_set_task_trigovrflw(int8_t task_trigovrflw); // Trigger overflow\nvoid rtc_timer_set_interrupt_set(int8_t interrupt_set); // Set interrupt\nvoid rtc_timer_set_prescaler(int16_t prescaler);        // Set prescaler\nvoid rtc_timer_set_cc0(int32_t cc0);                    // Set compare/capture 0\nvoid rtc_timer_set_cc1(int32_t cc1);                    // Set compare/capture 1\nvoid rtc_timer_set_cc2(int32_t cc2);                    // Set compare/capture 2\nvoid rtc_timer_set_cc3(int32_t cc3);                    // Set compare/capture 3\n// For high-level timing, use HAL_delay() or HAL_getTick() instead","peripheral-apis#Peripheral APIs":"","analog-front-end-afe#Analog Front-End (AFE)":"#include \"afe.h\"\n// AFE configuration\ntypedef struct {\n    uint32_t gain;\n    uint32_t bandwidth;\n    bool enable_bias;\n} afe_config_t;\n// AFE operations\nvoid afe_init(afe_config_t *config);\nvoid afe_enable(void);\nvoid afe_disable(void);\nuint32_t afe_read_status(void);","baseband-processor#Baseband Processor":"#include \"baseband.h\"\n// Baseband modes\ntypedef enum {\n    BASEBAND_MODE_BLE,\n    BASEBAND_MODE_LRWPAN,\n    BASEBAND_MODE_PROPRIETARY\n} baseband_mode_t;\n// Baseband operations\nvoid baseband_init(baseband_mode_t mode);\nvoid baseband_start_rx(void);  \nvoid baseband_start_tx(uint8_t *data, uint32_t length);\nbool baseband_packet_ready(void);\nuint32_t baseband_read_packet(uint8_t *buffer, uint32_t max_length);","sensor-adc#Sensor ADC":"#include \"sensor_adc.h\"\n// ADC configuration\ntypedef struct {\n    uint32_t sample_rate;\n    uint8_t resolution;\n    uint8_t reference;\n} adc_config_t;\n// ADC operations\nvoid sensor_adc_init(adc_config_t *config);\nvoid sensor_adc_start_conversion(uint8_t channel);\nbool sensor_adc_conversion_complete(void);\nint32_t sensor_adc_read_result(void);\nfloat sensor_adc_read_voltage(uint8_t channel);","serialtl-protocol-specification#SerialTL Protocol Specification":"","frame-format#Frame Format":"| SOF | LEN | CMD | ADDR | DATA | CRC |\n|  1  |  1  |  1  |  4   |  N   |  2  |\nField\tSize\tDescription\tSOF\t1 byte\tStart of frame (0xAA)\tLEN\t1 byte\tPayload length\tCMD\t1 byte\tCommand type\tADDR\t4 bytes\tTarget address\tDATA\tN bytes\tData payload\tCRC\t2 bytes\tCRC-16 checksum","command-types#Command Types":"Command\tValue\tDescription\tREAD\t0x01\tMemory read\tWRITE\t0x02\tMemory write\tBURST_READ\t0x03\tBurst read\tBURST_WRITE\t0x04\tBurst write\tSTATUS\t0x05\tStatus query\t\nDefault baud rate is 2,000,000 for simulation and host communication. Hardware implementations may use different rates.","memory-map#Memory Map":"","core-system-addresses#Core System Addresses":"Region\tStart Address\tEnd Address\tDescription\tROM\t0x0000_0000\t0x0000_FFFF\tBoot ROM\tRAM\t0x8000_0000\t0x8000_FFFF\tSystem RAM\tMMIO\t0x1000_0000\t0x1FFF_FFFF\tMemory-mapped I/O","peripheral-base-addresses#Peripheral Base Addresses":"Peripheral\tBase Address\tSize\tUART\t0x1000_0000\t0x1000\tGPIO\t0x1001_0000\t0x1000\tTimer\t0x1002_0000\t0x1000\tAFE\t0x1003_0000\t0x1000\tBaseband\t0x1004_0000\t0x1000\tADC\t0x1005_0000\t0x1000","error-codes#Error Codes":"","system-error-codes#System Error Codes":"Code\tName\tDescription\t0x00\tSUCCESS\tOperation completed successfully\t0x01\tINVALID_PARAM\tInvalid parameter provided\t0x02\tTIMEOUT\tOperation timed out\t0x03\tNOT_READY\tHardware not ready\t0x04\tBUSY\tResource is busy\t0x05\tNOT_SUPPORTED\tFeature not supported","communication-error-codes#Communication Error Codes":"Code\tName\tDescription\t0x10\tUART_ERROR\tUART communication error\t0x11\tCRC_ERROR\tCRC checksum mismatch\t0x12\tFRAME_ERROR\tInvalid frame format\t0x13\tOVERFLOW\tBuffer overflow\t0x14\tUNDERRUN\tBuffer underrun","development-tools#Development Tools":"","test-vector-generation#Test Vector Generation":"cd sw\npython tl_host_sim.py --output test_vectors.bin --commands read,write,burst","logic-analyzer-integration#Logic Analyzer Integration":"Pin assignments for debugging:\nSerialTL Clock: Pin A1\nSerialTL Data: Pin A2-A9\nASC Signals: Pin B1-B4\nDebug UART: Pin C1-C2","performance-profiling#Performance Profiling":"#include \"performance.h\"\n// Start profiling\nperf_start_timer();\n// Your code here\n// Get elapsed time\nuint32_t elapsed_us = perf_get_elapsed_us();\nprintf(\"Execution time: %d us\\n\", elapsed_us);\nFor detailed register specifications, see the SCuM-V23 Archive or SCuM-V24B documentation."}},"/archive/scum-v23/digital-core":{"title":"Digital Core","data":{"key-features#Key Features":"RV32IMAFC Single Rocket Core\n3 clocks for CPU core and peripherals:\n200 MHz CPU clock\n32 MHz ADC clock for BLE/IEEE 802.15.4 baseband-modem and precision sigma-delta ADC\n1MHz RTC clock\nOn-chip SRAM\n256kB scratchpad (\"L2\")\n8kB 2 way I\nJTAG, UART, QSPI Flash, GPIO\nInterrupt controller\nPLIC (platform level)\nCLINT (core level)\nRTC capture and compare peripheral","power-consumption#Power Consumption":"Power consumption comparison of the core running a program with baseband register read/write and ALU usage. VCC=0.85V, CPU clock=200MHz\n\tInternal Power (mW)\tSwitching Power (mW)\tLeakage Power (mW)\tTotal Power (mW)\tSCuM-V22 in Lab\t11.9\t-\t36\t42.5\tSCuM-V23 dynamic power simulation\t7.9\t3.2\t0.060\t11.2\t\nBased on simulations, total power consumption of the core decreased by 73% from SCuM-V22 to SCuM-V23. This improvement was achieved by reducing leakage power in the SRAM cells.","boot-process#Boot Process":"Method\tBOOT_SEL Value\tBoot Address\tInterface\tBoot Process Description\tSelf Boot\t1\t0x2000_0000\tSPI\tSPI flash content is copied to memoryJump to self boot base address\tTethered Boot\t0\t0x0000_0000\tTSI & JTAG\t1. Boot ROM configures a trap handler, and enters a wait for interrupt loop.2. Use JTAG, TSI, or other external debugging tools to program the on-chip memory3. Use JTAG, TSI, or other external tools to trigger a software interrupt (MSIP)4. Boot ROM handles interrupt, jumps to the program memory."}},"/archive/scum-v23/encryption-modules":{"title":"Encryption Modules","data":{"":"Establish secure communication between two devices in following steps:\nShare key Elliptic Curve Cryptography (ECC)\nSender encrypts message using Advanced Encryption Standard (AES) and shared key\nReceiver decrypts message using AES and shared key\nReceiver verifies message integrity using SHA-256","ecc#ECC":"ECC uses Chisel implementation and calls the Accelerator through C for math operations. Multiplier sizing is optimized.","aes#AES":"AES uses Chisel implementation and AES is synthesizable on a Rocket chip. Users can call AES accelerator functions through software by utilizing software interrupts. The process involves loading the encryption key and message, initiating the encryption or decryption process, and optionally utilizing diagnostic tools to monitor cycle time for computation completion. The implementation has been thoroughly tested using C testbenches and validated with third-party online software tools. On average, it takes approximately 6 cycles per word, which equates to about 10 nanoseconds per byte for AES operations.","sha-256#SHA-256":"SHA-256 part combines multiple hash functions for its operation. It divides data into eight 16-bit chunks, denoted as A to H, and performs bitwise XOR, AND, and bit-shifting operations on these chunks. It shares similar implementation and capabilities with an AES accelerator, with the exception of its hashing functionality. The project includes C testbenches, similar to those used for AES, and has been verified using third-party online software tools. On average, it takes approximately 107 cycles to process 256 bits of data, which translates to about 70 nanoseconds per byte for hash computations."}},"/archive/scum-v23":{"title":"SCuM-V23 Specification","data":{"":"This document describes the Single-Chip Micro Mote V (SCuM-V), a 16nm system-on-chip (SoC) for internet-of-things (IoT) applications, developed as part of the 2022 offering of EE194/EE290C Special Topics in Circuit Design class.","resource-index#Resource Index":"Resource\tDescription\tLink\tSCuM-V23 End of Semester Review\tFinal design review from Sp23\tGoogle Slides\tSCuM-V23 Mid-Semester Review\tMid-semester design review from Sp23\tGoogle Slides\tAnalog RF Simulations\tLocations and information on running RF analog simulations\tGoogle Doc\tSCuM-V22 Bringup Status\tArchive of SCuM-V22 bringup measurements\tGoogle Slides","system-overview#System Overview":"The SCuM-V23 chip offers several GPIO pins, a single UART bus, QSPI Flash, and an on-chip, crystal-free RTC with capture and compare registers. This iteration of the chip did not support I2C or an AES accelerator.SCuM-V23 has several new features introduced over its predecessor SCuM-V22:\n32-bit Rocket core with cryptography acceleration\nSwitched capacitor DC-DC converter cascaded with LDOs\n90 GHz FMCW radar transmitter\n18-bit µV-precision ADC","architecture-sections#Architecture Sections":"Select from the navigation menu to explore detailed specifications for each subsystem.","core-systems#Core Systems":"Overview - System overview and block diagram\nDigital Core - 32-bit RISC-V processor and memory system\nDigital Baseband - Dual-mode BLE/IEEE 802.15.4 baseband-modem","analog-systems#Analog Systems":"Power System - Switched capacitor converter, LDOs, and references\nOscillators - Clock generation systems\n2.4 GHz Transceiver - Radio front-end for wireless communication\n94 GHz Radar - FMCW radar transmitter\nµV-ADC - High-precision delta-sigma ADC for sensor applications","security#Security":"Encryption Modules - AES, ECC, and SHA-256 acceleration","electrical-characteristics#Electrical Characteristics":"This section requires completion with detailed electrical specifications and performance parameters.","usage-scenarios#Usage Scenarios":"This section requires completion describing various application scenarios and operating modes.","revision-history#Revision History":"v1.0 - Initial release\nv0.9 - Preliminary draft","appendix#Appendix":"This section requires completion with additional details, references, or supplementary material."}},"/archive/scum-v23/oscillators":{"title":"Oscillators","data":{"":"This section is incomplete and contains placeholder questions for documentation completion.\nThe following topics need to be documented:\nWhat clock domains are present?\nHow is the system intended to work if fully functional?\nWhat tuning accessibility do we have?\nWhat are minimum/maximum frequencies?"}},"/archive/scum-v23/overview":{"title":"Overview","data":{"":"This document describes the Single-Chip Micro Mote V (SCuM-V), a 16nm system-on-chip (SoC) for internet-of-things (IoT) applications, developed as part of the 2022 offering of EE194/EE290C Special Topics in Circuit Design class.The SoC is designed around the RISC-V 5-stage in-order Rocket processor, generated by the RocketChip generator, embedded in the Chipyard framework. It features a crystal-free design with custom dual-mode IEEE 802.15.4 and Bluetooth Low Energy (BLE) transceiver. The SoC is implemented in the Intel 16 FinFET process.The SCuM-V chip offers several GPIO pins, a single UART bus, QSPI Flash, and an on-chip, crystal-free RTC with capture and compare registers.\nThis iteration of the chip did not support I2C or an AES accelerator.SCuM-V23 has several new features introduced over its predecessor SCuM-V22:\n32-bit Rocket core with cryptography acceleration\nSwitched capacitor DC-DC converter cascaded with LDOs\n90 GHz FMCW radar transmitter\n18-bit µV-precision ADC","block-level-diagram--chip-features#Block Level Diagram + Chip Features":"","32-bit-risc-v-core#32-bit RISC-V Core":"The SoC includes a 32-bit Rocket, which has a high-performance single-issue in-order execution pipeline, with a peak sustainable execution rate of one instruction per clock cycle. The core supports Machine and User privilege modes as well as standard Integer, Multiply, Atomic, Floating-Point and Compressed RISC‑V extensions (RV32IMAFC).Detailed description of the core is in Chapter 3.","on-chip-memory-system#On-Chip Memory System":"The Rocket core has a 8kB I and a 256kB scratchpad acting as L2 memory.","busses#Busses":"The design includes a system, peripheral, control, and front bus. The Rocket Tile communicates through the system bus to the remaining three buses. The control bus accesses BootROM, PLIC/CLINT, and the debug interface. The frontend bus handles DMA devices.","interrupts#Interrupts":"Two interrupt controllers for handling MMIO are attached to the control bus, the platform level interrupt controller and the core local interrupts. Core local interrupts are used for timer and the software while the PLIC interacts with the peripherals.","dual-mode-bleieee-802154-transceiver#Dual-Mode BLE/IEEE 802.15.4 Transceiver":"A dual-mode transceiver that supports both Bluetooth Low-Energy and IEEE 802.15.4 modes of operation. In the Bluetooth LE operating mode, the transceiver is capable of sending and receiving BLE Link Layer packets at a rate of 1Msym/s. In IEEE 802.15.4 operating mode, the transceiver sends and receives 802.15.4 PHY packets at 2 Msym/s.The CPU is able to provide packet payloads to the digital baseband using DMA. Incoming packets will trigger multiple interrupts and provide the packet to the CPU via DMA. Control, status, and tuning registers are exposed to the CPU via MMIO. This includes a large suite of parameters of the transceiver (e.g. radio mode, channel tuning) that are accessed with these memory-mapped registers."}},"/archive/scum-v23/radar":{"title":"94 GHz FMCW Radar Transmitter","data":{"":"The frequency-modulated continuous wave (FMCW) radar transmitter is designed to generate linear chirps with the following high-level specifications:\nParameter\tValue\tCenter frequency\t94 GHz\tMaximum chirp bandwidth\t1 GHz\t\nLinear chirps over time with a center frequency of 94 GHz:The radar transmitter is implemented with a Class A voltage-controlled 47 GHz oscillator with a varactor driven by a ramp voltage.\nThe ramp voltage is generated digitally by an 8-bit counter register whose output feeds into an R-2R DAC.\nThe output of the VCO is fed into a frequency doubler, and the resulting 94 GHz signal is amplified by the PA.A center frequency of 94 GHz was chosen because Yahia, a graduate student advised by Prof. Niknejad, had recently taped out a 90 GHz PA in February 2023 and Prof. Niknejad suggested to use Yahia's PA for this radar transmitter. As a result, the PA is courtesy of Yahia.","system-overview#System Overview":"Radar system-level diagram:\nUnlike the other blocks on the chip, the radar transmitter has two dedicated power rails, VDD_RADAR and VDD_PA, that are not regulated internally and must be sourced externally. Nominally, VDD_RADAR should be 1 V, and VDD_PA should be 0.75 V.","ramp-generator#Ramp Generator":"The ramp generator is a digital circuit responsible for outputting an 8-bit ramp output that feeds into the R-2R DAC. Internally, there is a 32-bit counter register that is clocked by the CPU clock and used to generate the ramp output.There are two states of the ramp generator: STATE_IDLE and STATE_RAMP.\nIn STATE_IDLE, the ramp generator waits for ramp_generator_num_idle_cycles clock cycles before it moves to the STATE_RAMP state.\nIn STATE_RAMP, the ramp output is initially set to ramp_generator_frequency_step_start. Every ramp_generator_num_cycles_per_frequency clock cycles, the ramp output is incremented. Once the ramp output has been incremented ramp_generator_num_frequency_steps times, the ramp output is reset to ramp_generator_frequency_step_start, and the state machine moves back to the STATE_IDLE state. The ramp is now complete.\nThe reason for allowing the CPU to set ramp_generator_frequency_step_start as well as ramp_generator_num_frequency_steps is that the varactor's capacitance is non-linear with respect to the control voltage. Therefore, the control registers should be set, so that the ramp voltage causes the VCO to sweep linearly over the desired chirp bandwidth.Ramp generator output:","r-2r-dac#R-2R DAC":"The R-2R DAC converts the 8-bit ramp output from the ramp generator into an analog ramp voltage between 0 V and 1 V that controls the varactor in the VCO.\nThe resistor values used are 1k and 2k.","vco#VCO":"The VCO is a class A VCO with a 4-bit capacitive DAC ranging from 2 fF to 16 fF.\nUnlike the capacitive DAC, where a higher tuning code corresponds to a lower frequency, the varactor's capacitance decreases as a function of the control voltage. However, since the frequency is sensitive to the control voltage, the control voltage is not brought out as a debug signal.\nIn simulation, the VCO draws about 7 mW of power.VCO schematic:","frequency-doubler#Frequency Doubler":"The frequency doubler uses a modified cross-coupled pair with a resonant LC tank to double the VCO output's frequency.\nIn simulation, the frequency doubler draws about 16 mW of power.Frequency doubler schematic:","pa#PA":"The PA was designed and laid out by Yahia with minor modifications for SCuM-V23.\nThe PA consists of a driver stage and an output stage and consumes up to 60 mA at a supply voltage of 0.75 V.","register-map#Register Map":"The radar configuration registers are part of the Scumvtuning block, which contains a set of memory-mapped registers for tuning analog blocks. The base address of Scumvtuning is 0x0000_A000.\nRegister\tName\tSize (bits)\tFunction\t0x0D\tramp_generator_clk_mux_sel\t1\tUnused.\t0x0E\tramp_generator_enable\t1\tInitial 1b'1.Enables the ramp output.\t0x0F\tramp_generator_frequency_step_start\t8\tInitial: 8b'0.Sets the initial ramp output for each ramp.\t0x10\tramp_generator_num_frequency_steps\t8\tInitial: 8b'0.Sets the number of LSBs the ramp output should increment by for each ramp.\t0x11\tramp_generator_num_cycles_per_frequency\t24\tInitial: 24b'0.Sets the number of clock cycles before incrementing the ramp output.\t0x14\tramp_generator_num_idle_cycles\t32\tInitial: 32b'0.Sets the number of clock cycles to idle between ramps.\t0x18\tramp_generator_rst\t1\tInitial: 32b'1.Resets the ramp generator's counter and ramp output.\t0x19\tvco_cap_tuning\t5\tInitial: 5b'0.Tunes the 4-bit capacitive DAC of the VCO. The MSB is unused.\t0x1A\tvco_enable\t1\tInitial: 1b'1.Unused.\t0x1B\tvco_div_enable\t1\tInitial: 1b'1.Unused.\t0x1C\tpa_enable\t1\tInitial: 1b'1.Unused.\t0x1D\tpa_bypass\t1\tInitial: 1b'0.Unused.\t0x1E\tpa_input_mux_sel\t1\tInitial: 1b'0.Unused.","layout#Layout":"Final radar layout: The total area is 300 um x 200 um."}},"/bootloading-guide":{"title":"Bootloading Guide","data":{"":"Complete guide for loading and executing firmware on the SCuM-V chip through the FPGA controller.","prerequisites#Prerequisites":"FPGA programmed with SCuM-V Controller bitstream (see FPGA Programming Guide)\nRISC-V firmware compiled (see Firmware Development)\nPython 3.x with serial communication libraries\nProper hardware connections established\nThis guide assumes you have completed the FPGA Programming and have a working SCuM-V Controller bitstream loaded on your Arty A7-100T.","communication-interfaces#Communication Interfaces":"The SCuM-V Controller supports two primary communication paths:","serialtl-tilelink-over-uart#SerialTL (TileLink over UART)":"Purpose: Digital subsystem communication\nProtocol: TileLink transactions over UART\nUse Cases: Memory access, register configuration, firmware loading","analog-scan-chain-asc#Analog Scan Chain (ASC)":"Purpose: Analog subsystem configuration\nProtocol: Shift-register based scan chain\nUse Cases: AFE tuning, power management, analog block configuration","host-scripts-overview#Host Scripts Overview":"","tl_hostpy---serialtl-interface#tl_host.py - SerialTL Interface":"Primary script for SCuM-V digital communication:\ncd sw\npython tl_host.py [options]\nKey Features:\nFirmware programming via SerialTL\nMemory read/write operations\nRegister configuration and debugging\nBurst transfer capabilities\nCommand Line Arguments:\n-p/--port: Serial port (default: COM6)\n-t/--target: Target application name (default: template)\n--baud: Baud rate (default: 1,000,000)\n--batch: Batch size during flashing (default: 1)\nConfiguration:\nDefault Baud Rate: 1,000,000 (can be overridden)\nProtocol: TileLink-UH (Uncached Heavyweight)\nInterface: UART/SerialTL bridge","clientpy---analog-scan-chain-interface#client.py - Analog Scan Chain Interface":"Script for analog subsystem control:\ncd hw  \npython client.py [scan_chain_commands]\nKey Features:\nAnalog front-end configuration\nPower system control\nOscillator and PLL tuning\nSensor ADC calibration","firmware-bootloading-process#Firmware Bootloading Process":"","step-1-prepare-firmware-binary#Step 1: Prepare Firmware Binary":"Build Firmware\ncd sw/scum_firmware\nmake BUILD_MODE=BRINGUP\nVerify Binary Generation\nls build/*.bin\n# Expected: build/simple.bin (or your target application)","step-2-establish-communication#Step 2: Establish Communication":"Identify COM Port\nWindows: Check Device Manager for \"USB Serial Port (COMx)\"\nLinux/macOS: Look for /dev/ttyUSBx or /dev/ttyACMx\nTest Basic Communication\ncd sw\npython tl_host.py -p COMx","step-3-load-firmware#Step 3: Load Firmware":"Basic Firmware Loading:\n# Default target (template)\npython tl_host.py -p COMx\n# Specify target application\npython tl_host.py -p COMx -t simple\npython tl_host.py -p COMx -t afe_test\nAdvanced Loading Options:\n# Custom baud rate\npython tl_host.py -p COMx --baud 115200\n# Custom batch size for faster flashing\npython tl_host.py -p COMx --batch 512","step-4-execute-firmware#Step 4: Execute Firmware":"Start Execution:\nThe tl_host.py script automatically flashes the binary and triggers execution. Firmware starts running immediately after flashing completes.\n# Firmware execution is automatic after flashing\n# No additional commands needed","advanced-bootloading-operations#Advanced Bootloading Operations":"","memory-operations#Memory Operations":"Memory Operations:\nThe current tl_host.py script is primarily designed for firmware flashing. Advanced memory operations require modification of the script or direct use of the TileLinkHost class methods.\n# Example using TileLinkHost class directly\nfrom tl_host import TileLinkHost\nimport serial\n# Initialize connection\nser = serial.Serial('COM6', 1000000, timeout=2)\ntl = TileLinkHost(ser)\n# Read from address\ndata = tl.read_address(0x80000000)\n# Write to address\ntl.write_address(0x80000000, 0xDEADBEEF)","register-configuration#Register Configuration":"Digital Core Registers:\n# Using TileLinkHost class for register access\nfrom tl_host import TileLinkHost\nimport serial\nser = serial.Serial('COM6', 1000000, timeout=2)\ntl = TileLinkHost(ser)\n# Read UART registers\ntl.read_uart_registers()\n# Read baseband registers\ntl.read_baseband_registers()","debugging-support#Debugging Support":"UART Console Monitoring:\nFor monitoring firmware output, use a standard terminal program (PuTTY, minicom, etc.) on the UART pins of your hardware setup.\n# Use external terminal for monitoring\n# Linux/macOS: minicom, screen\n# Windows: PuTTY, TeraTerm\nMemory Analysis:\n# Using TileLinkHost for memory operations\ntl.memory_scan()  # Built-in memory scan function","analog-subsystem-configuration#Analog Subsystem Configuration":"","afe-analog-front-end-setup#AFE (Analog Front-End) Setup":"cd hw\npython client.py --afe-config --gain 10 --bandwidth 1MHz","power-system-configuration#Power System Configuration":"# Configure power domains\npython client.py --power-config --domain digital --voltage 1.2V\n# Enable low-power modes\npython client.py --power-config --sleep-mode deep","oscillator-tuning#Oscillator Tuning":"# Set reference oscillator frequency\npython client.py --osc-config --ref-freq 32.768kHz\n# Configure PLL settings\npython client.py --pll-config --target-freq 100MHz","communication-protocol-details#Communication Protocol Details":"","serialtl-packet-format#SerialTL Packet Format":"SerialTL uses a custom framing protocol over UART. Refer to hw/scumv-controller/stl_packet_diagram.svg for detailed packet structure.\nPacket Structure:\n[START] [LENGTH] [OPCODE] [ADDRESS] [DATA] [CHECKSUM] [END]\nTransaction Types:\nGet: Read operation (address → data)\nPut: Write operation (address + data)\nPutPartial: Partial write with byte enables","asc-protocol-details#ASC Protocol Details":"Scan Chain Structure:\nTotal Length: Variable (depends on enabled blocks)\nClock Domain: Separate SCAN_CLK from system clock\nData Format: MSB-first shift register\nBlock Addressing:\n[BLOCK_ID] [REG_ADDR] [DATA_BITS]","troubleshooting#Troubleshooting":"","communication-issues#Communication Issues":"UART Connection Problems:\n# Test raw UART connection\npython -c \"import serial; s=serial.Serial('COMx', 1000000); print('Connected')\"\n# Try different baud rates\npython tl_host.py -p COMx --baud 115200\nProtocol Errors:\nVerify baud rate matches FPGA configuration\nCheck for EMI/noise affecting signal integrity\nEnsure proper ground connections","firmware-loading-failures#Firmware Loading Failures":"Verification Errors:\n# Try smaller batch sizes for reliability\npython tl_host.py -p COMx --batch 64\n# Try lower baud rate\npython tl_host.py -p COMx --baud 115200\nMemory Access Issues:\nVerify target memory addresses are valid\nCheck for memory protection or bus errors\nEnsure firmware size fits available memory","analog-configuration-issues#Analog Configuration Issues":"Scan Chain Verification:\n# Test scan chain connectivity\npython client.py --scan-test --verbose\n# Verify block responses\npython client.py --block-test --all-blocks\nConfiguration Validation:\nCheck analog supply voltages\nVerify reference clock stability\nEnsure proper bias current settings","performance-optimization#Performance Optimization":"","transfer-speed#Transfer Speed":"Optimal Baud Rates:\nSimulation: 2,000,000 bps (fast turnaround)\nHardware: 115,200 bps (reliable operation)\nDebug: 9,600 bps (maximum compatibility)\nOptimized Transfers:\n# Use larger batch sizes for faster transfers\npython tl_host.py -p COMx --batch 1024","power-considerations#Power Considerations":"Efficient Bootloading:\n# Use optimal batch size to minimize programming time\npython tl_host.py -p COMx --batch 256\n# Configure analog power states via scan chain\npython client.py [scan_chain_power_commands]","script-customization#Script Customization":"","extending-tl_hostpy#Extending tl_host.py":"Example custom operations:\n# Add to tl_host.py\ndef custom_test_sequence(port):\n    # Custom test implementation\n    write_register(0x40000000, 0x12345678)\n    result = read_register(0x40000004)\n    return validate_result(result)","batch-operations#Batch Operations":"# Create batch script for repeated operations\ncat > batch_program.sh << EOF\n#!/bin/bash\npython tl_host.py -p COM3 -t app1\nsleep 5\npython tl_host.py -p COM3 -t app2\nEOF","integration-with-development-workflow#Integration with Development Workflow":"","automated-testing#Automated Testing":"# Continuous integration script\nmake -C sw/scum_firmware clean all\npython tl_host.py -p COM3 -t test_suite\n# Use external terminal for monitoring output","debugging-integration#Debugging Integration":"GDB Remote Debugging (Future Enhancement):\n# GDB integration not currently available\n# Consider using JTAG debugging through FPGA\nRelated Guides:\nFPGA Programming → - FPGA bitstream loading\nFirmware Development → - Firmware compilation\nHardware Setup → - Physical connections"}},"/archive/scum-v23/radio":{"title":"2.4 GHz Transceiver","data":{"radio-architecture#Radio Architecture":"The radio operates within the frequency range 2.4 to 2.4835 GHz covering 70 1MHz RF channels. The receive chain should be sensitive to an input power range of -70 dBm to -10 dBm and achieve a BER of 0.1% or an SNR of 12.5 dB.","radio-final-block-diagram#Radio Final Block Diagram":"","system-overview#System Overview":"The SCuM-V23 radio subsystem includes:\nLow Noise Amplifier (LNA): Provides initial signal amplification\nMixer: Frequency down-conversion for baseband processing\nTransimpedance Amplifier (TIA): Current-to-voltage conversion\nBandpass Filter (BPF): Channel selection and filtering\nVariable Gain Amplifier (VGA): Adjustable signal amplification\nVoltage Controlled Oscillator (VCO): Local oscillator generation","transmitter#Transmitter":"The transmitter is designed to operate in the 2.4 GHz ISM band and be standards-compliant with IEEE 802.15.4 and BLE. The tuning range of the 4.8 GHz DCO is 4.88 GHz ± 0.5 GHz with less than 40 ppm of resolution (less than 192 kHz), corresponding to 2.44 GHz ± 0.25 GHz after the divider.Transmitter schematic: The divider divides the 4.8 GHz DCO signal down to 2.4 GHz and also generates the differential in-phase and quadrature components for the mixer.","system-diagram#System Diagram":"The radio system is optimized for low-power operation while maintaining sufficient sensitivity for IoT applications.","key-specifications#Key Specifications":"Parameter\tValue\tFrequency Range\t2.4 - 2.4835 GHz\tNumber of Channels\t70 × 1MHz\tSensitivity\t-70 to -10 dBm\tTarget BER\t0.1%\tRequired SNR\t12.5 dB\tVCO Tuning Range\t4.88 GHz ± 0.5 GHz","design-considerations#Design Considerations":"IEEE 802.15.4 and BLE compatibility\nLow power consumption for battery operation\nIntegrated antenna interface\nDigital control for frequency selection\nOptimized for single-chip integration\nFor detailed register maps and configuration information, refer to the complete system documentation."}},"/digital-baseband":{"title":"Digital Baseband-Modem","data":{"dual-mode-baseband-modem#Dual-Mode Baseband-Modem":"The Dual-Mode Baseband-Modem (BM) is responsible for handling the transmission and reception of both Bluetooth LE and IEEE 802.15.4 packets. For Bluetooth Low Energy, the BM handles Bluetooth Low Energy 1M Uncoded Link Layer Packets. For IEEE 802.15.4, the BM handles packets transmitted according to the PHY standard for the O-QPSK modulation in the 2.4 GHz band. Additionally the BM exposes an interface for the CPU to read/write various information (e.g. tuning bits) to the analog RF.There are two primary sub-components in the Baseband-Modem, the Baseband, and the Modem. The baseband is responsible for the bit-stream processing of incoming and outgoing packets. The modem is responsible for modulation on the TX side, and digital image rejection and demodulation on the RX side.","architecture-overview#Architecture Overview":"","baseband-modem-frontend#Baseband-Modem Frontend":"","commands-and-mmio-registers#Commands and MMIO Registers":"The baseband-modem (BM) block contains a set of memory mapped registers used for passing commands to the BM, tuning analog RF components, and making BM status visible to the CPU. The address map is shown below. Note that the addresses are relative to the BM's base attachment address. For example, if the BM is attached at 0x8000, then the address of 0x04 corresponds to 0x8004.\nADDR\tDATA\tSize (bits)\tDescription\t0x00\tInstruction\t32\tInstruction received from processor. Contains 4 bits of primary instruction, 4 bits of secondary instruction, then 24 bits of data.\t0x04\tAdditional Data\t32\tAdditional data to write. Set data before writing instructions when applicable.\t0x08\tStatus 0\t32\t[2:0] Assembler State[5:3] Disassembler State[7:6] TX State[10:8] RX Controller State[12:11] TX Controller State[15:13] Controller State[23:16] ADC I data[31:24] ADC Q data\t0x0C\tStatus 1\t32\t[5:0] Modulation LUT index[10:6] I AGC LUT index[15:11] I DCOC LUT index[20:16] Q AGC LUT index[25:21] Q DCOC LUT index\t0x10\tStatus 2\t32\t[31:0] BLE CDR bit count\t0x14\tStatus 3\t32\t[31:0] LRWPAN CDR bit count\t0x18\tStatus 4\t32\t[31:0] LO/32 counter\t0x1C\tGeneral trim 0\t8\tGeneral trim bits (N/C)\t0x1D\tGeneral trim 1\t8\t[0] LO/32 input (external, not implemented)\t0x1E\tGeneral trim 2\t8\tGeneral trim bits (N/C)\t0x1F\tGeneral trim 3\t8\tGeneral trim bits (N/C)\t0x20\tGeneral trim 4\t8\tGeneral trim bits (N/C)\t0x21\tGeneral trim 5\t8\tGeneral trim bits (N/C)\t0x22\tGeneral trim 6\t8\tGeneral trim bits (N/C)\t0x23\tGeneral trim 7\t8\tDebug Enable (0 = debug enable)\t0x24\tI VGA gain control\t10\tManual VGA value if not using I AGC\t0x26\tI VGA attenuation reset\t1\treset the I AGC\t0x27\tI VGA attenuation useAGC\t1\tuse I AGC (manual VGA value if not)\t0x28\tI VGA attenuation sample window\t8\tI AGC sample window\t0x29\tI VGA attenuation ideal peak to peak\t8\tI AGC ideal peak to peak\t0x2A\tI VGA tolerance peak to peak\t8\tI AGC peak to peak tolerance\t0x2B\tI BPF CHP 0 & 1\t8\tI bandpass filter tuning\t0x2C\tI BPF CHP 2 & 3\t8\tI bandpass filter tuning\t0x2D\tI BPF CHP 4 & 5\t8\tI bandpass filter tuning\t0x2E\tI BPF CLP 0 & 1\t8\tI bandpass filter tuning\t0x2F\tI BPF CLP 2\t4\tI bandpass filter tuning\t0x30\tQ VGA gain control\t10\tManual VGA value if not using Q AGC\t0x32\tQ VGA attenuation reset\t1\treset the Q AGC\t0x33\tQ VGA attenuation useAGC\t1\tuse Q AGC (manual VGA value if not)\t0x34\tQ VGA attenuation sample window\t8\tQ AGC sample window\t0x35\tQ VGA attenuation ideal peak to peak\t8\tQ AGC ideal peak to peak\t0x36\tQ VGA tolerance peak to peak\t8\tQ AGC peak to peak tolerance\t0x37\tQ BPF CHP 0 & 1\t8\tQ bandpass filter tuning\t0x38\tQ BPF CHP 2 & 3\t8\tQ bandpass filter tuning\t0x39\tQ BPF CHP 4 & 5\t8\tQ bandpass filter tuning\t0x3A\tQ BPF CLP 0 & 1\t8\tQ bandpass filter tuning\t0x3B\tQ BPF CLP 2\t4\tQ bandpass filter tuning\t0x3C\tI DCO use\t1\ttoggle using I DCO\t0x3D\tI DCO reset\t1\treset the I DCO\t0x3E\tI DCO gain\t8\tset gain for I DCO (unsigned FixedPoint w/ 2 bit binary point)\t0x3F\tQ DCO use\t1\ttoggle using Q DCO\t0x40\tQ DCO reset\t1\treset the Q DCO\t0x41\tQ DCO gain\t8\tset gain for Q DCO (unsigned FixedPoint w/ 2 bit binary point)\t0x42\tDCOC tuning 1\t6\tManual I current DAC for stage 2 VGA value if not using I DCO\t0x43\tDCOC tuning 2\t6\tManual Q current DAC for stage 2 VGA value if not using Q DCO\t0x46\tMUX debug in\t10\tDebug configuration, input\t0x48\tMUX debug out\t10\tDebug configuration, output\t0x4A\tEnable RX I\t5\tManual enable RX I values {3'b0, mix, buf, vga_s1, vga_s2, bpf}\t0x4B\tEnable RX Q\t5\tManual enable RX Q values {3'b0, mix, buf, vga_s1, vga_s2, bpf}\t0x4C\tEnable VCO LO\t2\tManual enable VCO LO {6'b0, vco_lo, lna}\t0x50\tLUT command\t32\tLUT set instruction [3:0] LUT ID [9:4] address (index) [31:10] value\t0x54\tRX error message\t32\tInterrupt message, RX error message\t0x58\tRX finish message\t32\tInterrupt message, RX finish message\t0x5C\tTX error message\t32\tInterrupt message, TX error message\t0x60\tFIR command\t32\tFIR filter reprogramming instruction, [3:0] FIR ID [9:4] coefficient (index) [31:10] value\t0x64\tI VGA attenuation gain increase\t8\tI AGC gain increase step size (by LUT index)\t0x65\tI VGA attenuation gain decrease\t8\tI AGC gain decrease step size (by LUT index)\t0x66\tQ VGA attenuation gain increase\t8\tQ AGC gain increase step size (by LUT index)\t0x67\tQ VGA attenuation gain decrease\t8\tQ AGC gain decrease step size (by LUT index)\t\nThe processor should always write to the additional data register prior to writing to the instruction register for a given command. Writing to the register at 0x00 is the trigger for the BM to execute a given command.\nIn order to pass commands to the BM, two 32-bit registers at addresses 0x00 and 0x04 are utilized. The register at 0x04 contains the additional data field for a given command while the register at 0x00 contains the instruction.The format for a BM instruction is:\nBits\t31-8\t7-4\t3-0\tField\tData\tInstruction 2\tInstruction 1","list-of-commands#List of Commands":"Configure CommandConfigure baseband constants. The constant is selected using the instruction 2 field and set to the value specified in the additional data field. In the case that the secondary instruction is set to CONFIG_LUT, reference the LUT addresses provided in the explanations below.\nField\tData\tInstruction 2\tInstruction 1\tValue\tX unless CONFIG_LUT, then LUT address\tSee table\t0\t\nField\tAdditional Data\tValue\tValue for the constant to be set to\t\nInstruction 2\tName\t0x0\tCONFIG_RADIO_MODE\t0x1\tCONFIG_CRC_SEED\t0x2\tCONFIG_ACCESS_ADDRESS\t0x3\tCONFIG_SHR\t0x4\tCONFIG_BLE_CHANNEL_INDEX\t0x5\tCONFIG_LRWPAN_CHANNEL_INDEX\t\nConfiguration instruction descriptions(0x0) CONFIG_RADIO_MODE:\nSpecify the following in the Additional Data register (0x04) prior to issuing the instruction\n0: Set the radio transceiver mode to Bluetooth Low Energy\n1: Set the radio transceiver mode to IEEE 802.15.4 LR-WPAN\nValid in any radio mode.(0x1) CONFIG_CRC_SEED:\nSet the CRC (cyclic redundancy check) seed for the BLE and LR-WPAN CRC circuits to the value in the Additional Data register (0x04). This value changes for BLE and should be 0 for LR-WPAN(0x2) CONFIG_ACCESS_ADDRESS:\nSet the BLE Access Address for the BLE uncoded packet. This value must be provided by the CPU. More information may be found in the BLE Baseband section.\nAn access address of 0xFFFFFFF6 disables whitening of transmitted BLE packets\n(0x3) CONFIG_SHR:\nSet the LRWPAN SHR to match with for receiving a LRWPAN packet. This value must be provided by the CPU. According to 802.15.4 spec, it should be a fixed value of 0xA700 (only 2 bytes are matched due to lower hardware cost), but is programmable for flexibility.(0x4) CONFIG_BLE_CHANNEL_INDEX:\nValues for the channel index can range from 0 to 39, corresponding to BLE channel frequencies beginning at 2402 MHz until 2480 MHz. It is critical to note that the channel index from 0 to 39 is a direct mapping to channel frequencies - NOT the BLE channel numbering scheme that considers advertising channels separately. For example, setting CONFIG_BLE_CHANNEL_INDEX to 0 will result in a transmission with center frequency at 2402 MHz. This corresponds to BLE channel 37. More information(0x5) CONFIG_LRWPAN_CHANNEL_INDEX:\nValues for the channel index can range from 0 to 15, corresponding to LR-WPAN channel frequencies beginning at 2405 MHz until 2480 MHz.Send CommandTransmit a specified number of PDU header and data bytes. Bytes are retrieved by the BM by loading them from the specified address.\nField\tData\tInstruction 2\tInstruction 1\tValue\tNumber of bytes\tX\t1\t\nField\tAdditional Data\tValue\tLoad address\t\nReceive Enter CommandPlace the device into receive mode. If a message is picked up, it will be stored starting at the specified address address.\nField\tData\tInstruction 2\tInstruction 1\tValue\tX\tX\t2\t\nField\tAdditional Data\tValue\tStorage address\t\nReceive Exit CommandExit the device from receive mode. This command will succeed as long as the device has not yet matched an instruction preamble.\nField\tData\tInstruction 2\tInstruction 1\tValue\tX\tX\t3\t\nField\tAdditional Data\tValue\tX\t\nDebug CommandTurns on both the TX and RX paths according to the specified loopback mask before passing the specified number of PDU bytes in a loop. For simplicity the return data is stored at <load address + total bytes> rounded to the next byte aligned address. The loopback mask is used to determine at which point the data should be revered and sent back towards the CC.\nField\tData\tInstruction 2\tInstruction 1\tValue\tTotal bytes to send\tLoopback mask\t15\t\nField\tAdditional Data\tValue\tLoad address and base for store address calculation\t\nLoopback Mask\tLoopback Point\t0b0001 (0x1)\tEmpty\t0b0010 (0x2)\tIn the modem, loop the FSKTX output back in to the CDR in FSKRX\t0b0100 (0x4)\tEmpty\t0b1000 (0x8)\tEmpty\t\nLoopback diagram: Note that the FSKRX module handles loopback logic and directs the output of MSKTX & GFSK TX modules to respective CDR blocks","configuring-modem-luts#Configuring Modem LUTs":"The modem LUTs can be configured using the LUT command register in the MMIO map enumerated above (register offset 0x50).LUT IDs are defined as follows:0x0 - VCO_MOD:\n64-entry, 8-bit valued LUT that is sampled to produce frequency deviations from the center frequency. This LUT must be reloaded on each channel and mode change. 0 indicates the largest negative frequency deviation, 63 indicates the largest positive deviation, and 31 indicates no frequency deviation. Note that 0/63 should be +/-250kHz for BLE and +/-500kHz for LR-WPAN.0x1 - VCO_CT_BLE:\n40-entry LUT sampled with BLE channel index to produce coarse and medium tuning bits to drive the VCO to the center frequency of the BLE channel index selected. Does not apply when in LR-WPAN radio mode.0x2 - VCO_CT_LRWPAN:\n16-entry LUT that is sampled with the LR-WPAN channel index to produce the coarse and medium tuning bits to drive the VCO to the center frequency of the LR-WPAN channel index selected. Does not apply when in BLE radio mode.0x3 - AGC_I:\n64-entry LUT that is sampled to drive the VGA attenuation gain for the I channel VGA. Only the lower 32 entries are used.0x4 - AGC_Q:\n64-entry LUT that is sampled to drive the VGA attenuation gain for the Q channel VGA. Only the lower 32 entries are used.0x5 - DCO_I:\n64-entry LUT that is sampled to drive the current DAC for the I channel stage 2 VGA. Only the lower 32 entries are used.0x6 - DCO_Q:\n64-entry LUT that is sampled to drive the current DAC for the Q channel stage 2 VGA. Only the lower 32 entries are used.","configuring-the-fir-filter-coefficients#Configuring the FIR filter coefficients":"The FIR filter coefficients can be configured using the FIR command register in the MMIO map enumerated above (register offset 0x60).FIR IDs are defined as follows:0x0 - NONE:\nReserved0x1 - TX_GAUSSIAN:\n24-entry, 8-bit FixedPoint (2-bit fractional component) filter for BLE GFSK. Only 16 coefficients are used. Note the filter was designed to run at 8MHz (length = 2*cycles/bit) but there's a bug in the implementation. The short-term fix to get it working was to double the coefficients.0x2 - RX_HILBERT_I:\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for image rejection.0x3 - RX_HILBERT_Q:\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for image rejection. The output of the I and Q filters are summed to form the image rejected signal suitable for FSK demodulation.0x4 - RX_MATCH_SIN_F0:\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for matched filter for binary 0. Two templates (filters) are used to account for phase shift. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately.0x5 - RX_MATCH_COS_F0:\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for matched filter for binary 0. Two templates (filters) are used to account for phase shift. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately.0x6 - RX_MATCH_SIN_F1:\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for matched filter for binary 1. Two templates (filters) are used to account for phase shift. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately.0x7 - RX_MATCH_COS_F1:\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for matched filter for binary 1. Two templates (filters) are used to account for phase shift. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately.0x8 - RX_LPF:\n32-entry, 16-bit FixedPoint (12-bit fractional component) filter for bitrate filter of the matched filter output. Two filters with the same coefficients are used, one for 0s and another for 1s. Note BLE coefficients are loaded by default. LR-WPAN ones must be loaded separately.","interrupts#Interrupts":"The Baseband-Modem provides five interrupts as outputs from the Baseband Frontend. These interrupts provide the CPU with triggers for events from the transceiver module. The interrupts are described in the table below:Baseband-Modem interrupt table\nInterrupt Index\tName\tDescription\t0\tRX_ERROR\tTriggers on recognition of an error while the BM is in RX state. The MMIO register 0x54 will be populated with an RX_ERROR_MESSAGE. Presently not implemented.\t1\tRX_START\tTriggers when the baseband disassembler/correlator enters the busy state. Denotes that a packet has been received and demodulated, but has not yet been disassembled.\t2\tRX_FINISH\tTriggers when the disassembler has completed processing an incoming message. Populates the MMIO register RX_FINISH_MESSAGE at 0x58 with the length of the message.\t3\tTX_ERROR\tTriggers on recognition of an error while the BM is in TX state. The MMIO register 0x5C will be populated with an TX_ERROR_MESSAGE. Presently not implemented.\t4\tTX_FINISH\tTriggers when the modem has completed transmission of all bytes in the provided message. The DMA read response bytes must match the number of bytes specified in the Send Command for this interrupt to fire.","ieee-802154-lr-wpan-baseband#IEEE 802.15.4 LR-WPAN Baseband":"Baseband modulation/demodulation diagramThe LR-WPAN baseband transmission chain involves DMA packet disassembly, LR-WPAN packet assembly, CRC generation, bit-to-symbol translation, and symbol-to-chip translation before the final chip stream is provided to the modem for modulation. The packet is assembled according to the IEEE 802.15.4 (LR-WPAN) PPDU schematic (shown below).It is important to note the rates at each stage of the baseband TX chain. The standard calls for a 250 kb/s bitrate corresponding to packet assembly/packet disassembly. Following bit-to-symbol translation, the symbol rate becomes 62.5 ksym/s (where 4 bits specifies 1 symbol). Following symbol-to-chip translation, the chip rate now matches the LR-WPAN nominal baseband frequency of 2 MHz frequency or 2 Mchip/s (where 1 symbol specifies 32 chips). The inverse applies for the RX chain.During packet assembly, a frame check sequence is calculated as a 16-bit ITU-T CRC.CRC calculation diagramThe algorithm for the CRC begins by setting all remainder registers, r0...r15, to zero. Next, we start from the LSB and shift the MHR and payload into the divider. The FCS is then the remainder register after the last bit of the data is shifted in. Lastly, the FCS is appended to the data field so that register r0 is transmitted first.IEEE 802.15.4 PPDU SchematicThe frame check sequence (FCS) is appended to the end of the PPDU as the MAC footer (MFR) in the diagram above. If the result of CRC checking is false, the [flag] is set to high, before triggering a RX_ERROR message.PSDU SchematicThe preamble for 15.4 is a 32-bit sequence of all zeros. The SFD is loosely analogous to the Access-Address (AA) of the BLE Baseband in that they both uniquely identify the start of the packet for the protocol used.","bluetooth-low-energy-ble-baseband#Bluetooth Low Energy (BLE) Baseband":"BLE baseband and modulation/demodulation diagramBelow is the BLE Uncoded Packet format. All elements of the packet either are or depend on data that the CPU must set (which is taken care of by the SW implementation of the Link Layer). These values are communicated to the packet assembler and disassembler through the controller via the command system over MMIO.BLE PPDU SchematicThe Preamble is an alternating series of 1s and 0s that depends on the LSB of the Access-Address (AA). The CPU need not provide any additional control signals for this part of the packet.The Access-Address is a special value set by the SW Link Layer that determines whether a packet is valid or not. This value must be provided by the CPU and depends on past communications or may be set to some default value.The PDU is the already encrypted content of the packet, the CPU must provide this in its entirety. Through the DMA controller, the packet assembler will retrieve this from main memory. The packet disassembler will deliver a PDU to the main memory once one is received.The CRC (cyclic redundancy check) is derived from the Link Layer state (which must be provided by the CPU via MMIO register). In the receive chain, if the calculated CRC does not match the CRC found in the PDU, the [flag] is set to high.BLE CRC functional schematic","whitening#Whitening":"In order to avoid long continuous sequences of 1s and 0s in the transmitted data, the entire packet goes through a process known as whitening.Whitening diagramOutgoing data on the TX chain is whitened and incoming data is also \"de-whitened\"","unified-fsk-modem#Unified FSK Modem":"The modem sits between the digital baseband and the ADCs / DAC to analog RF. It is responsible for performing demodulation and modulation and clock and data recovery at a rate of 1Mbps for BLE or 2Mchip/s for LR-WPAN. Each cycle, the digital baseband either receives a new bit from the demodulator, or provides a new bit for transmission to the modulator.","tx-chain#TX Chain":"Modem TX chain schematicThe digital baseband bit-stream process outputs individual bits into a FIFO that will be consumed by the modem for use in modulation. For BLE transmissions, the bitstream is modulated using Gaussian frequency shift keying (GFSK). The modulator modulates the outgoing bits using at a rate of 1Msym/s, with a modulation index of 0.5. For LR-WPAN transmissions, the chipstream directly drives the modulation LUT. The output of the modulation LUT is an 8-bit unsigned integer value that indicates the FSK modulation away from the maximum frequency at that channel tuning.The 6-bit FSK modulation output, in conjunction with a 6 bit channel select value, are used to address into the Modulation LUT to retrieve input values for the VCO LO based on the channel index and modulation frequency offset. These decoding LUTs provide 8-bit values for LO coarse tuning, LO FSK, and the PLL division.","rx-chain#RX Chain":"Modem RX chain schematicAfter mixing, the analog I and Q signals go through ADCs to produce 8 bit output values. The ADCs are clocked on the negative edge of the digital system clock. On the falling system clock edge, the ADCs sample and latch the signals coming from analog RF. These sampled 8-bit values are then captured by rising-edge triggered flip-flops at the analog-digital boundary of the RX chain.","image-rejection#Image Rejection":"After mixing with the LO and being sampled by the I/Q ADCs, the Q signal for the signal (F_LO+F_IF) ends up +90° shifted from I while the image (F_LO-F_IF) ends up -90° shifted from I. A Hilbert filter shifts positive frequencies by +90° and negative frequencies by -90°. By applying it to the I signal and adding to the Q signal, this causes constructive interference for the desired signal and destructive interference for the image, heavily attenuating it. Note these filters are fully configurable (up to their maximum length) if needed.","fsk-demodulation#FSK Demodulation":"After image rejection, the matched filters (the optimal non-coherent demodulator!) and envelope detection serve to discriminate between positive and negative frequency deviations. A matched filter performs a convolution of the input signal with a \"template\" which is simply samples of the desired frequency up to the length of a bit/chip period. Due to phase shift, we must have sine and cosine templates and sum the two. Since the filters generate high frequency noise, we perform \"envelope detection\" after the matched filters to remove it and get a clean signal giving the magnitude of the match. Comparing the magnitude of each gives us the decision for the deviation.For an ADC clock of 32MHz, we need a 32-length filter for BLE and 16-length filter for LR-WPAN. For an IF of 2MHz, we need templates of 1.75MHz and 2.25MHz for BLE and 1.5MHz and 2.5MHz for LR-WPAN.","clock-and-data-recovery-cdr#Clock and Data Recovery (CDR)":"After FSK demodulation, we have an oversampled bitstream which must downsample to the appropriate bitrate. The goal of the CDR is to align the sampling window with the phase of the incoming bitstream.Our design has 3 integrators - early, present, late - which each look at a window (of length equal to the bit period) of the incoming bitstream but are offset from each other by 1 cycle. We then have a counter that decrements every cycle. When the counter hits 0, we return a sampled bit that is the value of the strongest integrator (determined by majority and number of 1s and 0s). We then reset the counter to a value that will cause the winning integrator in the next bit period to be closer to the present integrator (either by extending or shortening the amount of time to the next sample time).","automatic-gain-control-agc#Automatic Gain Control (AGC)":"The AGC supports a high dynamic range by keeping the ADCs near saturation. It tracks the minimum and maximum ADC values and increases or decreases the gain based on signal strength. It is recommended to keep the tolerance larger than the gain resolution to prevent oscillation.","dc-offset-compensation-dco#DC Offset Compensation (DCO)":"The DCO integrates the incoming signal, applies gain, and feeds back into the LUT to calibrate the VGA and remove DC offset.","example-radio-front-end-rfe#Example Radio Front-End (RFE)":"The example RFE operates in the 2.4G to 2.4835 GHz range, covering 70 1MHz RF channels. The receive chain functions from -70dBm to -10dBm with detailed interference specifications for in-band and out-of-band conditions. It uses a low-IF receiver and direct modulation transmitter architecture."}},"/digital-core":{"title":"Digital Core","data":{"key-features#Key Features":"RV32IMAFC Single Rocket Core\n3 clocks for CPU core and peripherals:\n200 MHz CPU clock\n32 MHz ADC clock for BLE/IEEE 802.15.4 baseband-modem and precision sigma-delta ADC\n1MHz RTC clock\nOn-chip SRAM\n256kB scratchpad (\"L2\")\n8kB 2 way I\nJTAG, UART, QSPI Flash, GPIO\nInterrupt controller\nPLIC (platform level)\nCLINT (core level)\nRTC capture and compare peripheral","power-consumption#Power Consumption":"Power consumption comparison of the core running a program with baseband register read/write and ALU usage. VCC=0.85V, CPU clock=200MHz\n\tInternal Power (mW)\tSwitching Power (mW)\tLeakage Power (mW)\tTotal Power (mW)\tSCuM-V22 in Lab\t11.9\t-\t36\t42.5\tSCuM-V23 dynamic power simulation\t7.9\t3.2\t0.060\t11.2\t\nBased on simulations, total power consumption of the core decreased by 73% from SCuM-V22 to SCuM-V24B. This improvement was achieved by reducing leakage power in the SRAM cells.","boot-process#Boot Process":"Method\tBOOT_SEL Value\tBoot Address\tInterface\tBoot Process Description\tSelf Boot\t1\t0x2000_0000\tSPI\tSPI flash content is copied to memoryJump to self boot base address\tTethered Boot\t0\t0x0000_0000\tTSI & JTAG\t1. Boot ROM configures a trap handler, and enters a wait for interrupt loop.2. Use JTAG, TSI, or other external debugging tools to program the on-chip memory3. Use JTAG, TSI, or other external tools to trigger a software interrupt (MSIP)4. Boot ROM handles interrupt, jumps to the program memory."}},"/firmware-development":{"title":"Firmware Development","data":{"":"Guide for developing RISC-V firmware for the SCuM-V chip.","risc-v-toolchain-setup#RISC-V Toolchain Setup":"","windows-setup#Windows Setup":"","install-msys2#Install MSYS2":"Download from https://www.msys2.org/ and follow installation instructions","install-risc-v-toolchain#Install RISC-V Toolchain":"Download xpack distribution: RISC-V GCC xPack\nExtract to desired location (e.g., C:\\riscv\\)","configure-msys2-environment#Configure MSYS2 Environment":"export PATH=/c/riscv/xpack-riscv-none-elf-gcc-13.2.0-2/bin:$PATH","linuxmacos-setup#Linux/macOS Setup":"Follow the comprehensive setup guide from the Baremetal-IDE documentation:Chipyard RISC-V Toolchain SetupThis guide covers:\nUbuntu/Debian package installation\nmacOS Homebrew setup\nBuilding from source\nEnvironment configuration","firmware-architecture#Firmware Architecture":"","project-structure#Project Structure":"","build-system#Build System":"The firmware uses a Makefile-based build system optimized for RISC-V cross-compilation.Basic Build Commands:\ncd sw/scum_firmware\nmake                    # Build default target (BRINGUP mode)\nmake clean             # Clean build artifacts  \nmake objdump           # Generate disassembly","build-modes#Build Modes":"The build system supports two different modes optimized for different environments:\nBuild Mode\tUsage\tDescription\tBRINGUP\tBUILD_MODE=BRINGUP (default)\tPost-silicon hardware testing\tSIM\tBUILD_MODE=SIM\tRTL simulation environment\t\nMode-Specific Build Commands:\n# Explicit mode specification\nmake BUILD_MODE=SIM\nmake BUILD_MODE=BRINGUP\n# Convenience targets\nmake simple-sim         # Build simple.c for simulation\nmake simple-bringup     # Build simple.c for hardware","build-configuration-build_configh#Build Configuration (build_config.h)":"Each build mode uses different system parameters defined in core/inc/build_config.h:SIM Mode Configuration:\nClock frequency: 200 MHz (fast simulation)\nUART baud rate: 921600 (high-speed simulation)\nUART stop bits: 2 (simulation robustness)\nBRINGUP Mode Configuration:\nClock frequency: 1 MHz (conservative hardware startup)\nUART baud rate: 115200 (standard hardware rate)\nUART stop bits: 1 (standard hardware setting)\nClock Frequency Tuning: The SYS_CLK_FREQ setting in build_config.h must match your hardware's actual clock configuration. Update this value when changing PLL or oscillator settings.","board-support-package-bsp#Board Support Package (BSP)":"","core-bsp-modules#Core BSP Modules":"Module\tDescription\tscum_hal\tHardware abstraction layer\tscum_hal_clint\tCore Local Interrupt Controller\tscum_hal_core\tRISC-V core utilities\tscum_hal_gpio\tGeneral purpose I/O\tscum_hal_plic\tPlatform-Level Interrupt Controller\tscum_hal_rcc\tReset and clock control\tscum_hal_uart\tUART communication","peripheral-drivers#Peripheral Drivers":"Driver\tHeader\tDescription\tAFE\tafe.h\tAnalog front-end control\tBaseband\tbaseband.h\tBaseband processing\tSensor ADC\tsensor_adc.h\tHigh-precision ADC interface\tRTC Timer\trtc_timer.h\tReal-time clock and timers\tSCuM-V Tuning\tscumvtuning.h\tChip tuning parameters\t\nAll BSP headers include comprehensive register definitions and utility macros for efficient hardware interaction.","application-development#Application Development":"","available-test-applications#Available Test Applications":"The firmware includes several test and example applications:\nApplication\tHeader\tPurpose\tAFE Test\tafe_test.h\tAnalog front-end validation\tBLE Loopback\tble_loopback.h\tBluetooth Low Energy testing\tLRWPAN Loopback\tlrwpan_loopback.h\t802.15.4 protocol testing\tNFC Test\tnfc_test.h\tNear-field communication\tPower Test\tpower_test.h\tPower system validation\tSensor ADC Test\tsensor_adc_test.h\tADC calibration and testing\tRTC Timer Test\trtc_timer_test.h\tTimer and clock testing","creating-new-applications#Creating New Applications":"","create-source-file#Create Source File":"// core/src/my_application.c\n#include \"scum_hal.h\"\n#include \"my_application.h\"\nint main(void) {\n    // Initialize hardware\n    scum_hal_init();\n    \n    // Your application logic\n    while(1) {\n        // Main loop\n    }\n    \n    return 0;\n}","create-header-file#Create Header File":"// core/inc/my_application.h\n#ifndef MY_APPLICATION_H\n#define MY_APPLICATION_H\n#include \"scum_hal.h\"\n// Function declarations\nvoid my_function(void);\n#endif","update-makefile#Update Makefile":"Add your source files to the build system configuration.","hardware-abstraction-layer-hal#Hardware Abstraction Layer (HAL)":"","core-hal-functions#Core HAL Functions":"// System initialization\nvoid HAL_init(void);\nuint64_t HAL_getTick(void);\nvoid HAL_delay(uint64_t time_us);\nvoid HAL_delay_cycles(uint64_t cycles);\n// GPIO operations  \nvoid HAL_GPIO_init(GPIO_TypeDef *GPIOx, GPIO_Pin pin);\nvoid HAL_GPIO_writePin(GPIO_TypeDef *GPIOx, GPIO_Pin pin, uint8_t value);\nuint8_t HAL_GPIO_readPin(GPIO_TypeDef *GPIOx, GPIO_Pin pin);\n// UART communication\nvoid HAL_UART_init(UART_TypeDef *UARTx, UART_InitTypeDef *UART_init);\nStatus HAL_UART_transmit(UART_TypeDef *UARTx, uint8_t *data, uint16_t size, uint32_t timeout);\nStatus HAL_UART_receive(UART_TypeDef *UARTx, uint8_t *data, uint16_t size, uint32_t timeout);\nvoid HAL_UART_finishTX(UART_TypeDef *UARTx);\n// RTC Timer operations (low-level)\nint32_t rtc_timer_get_coutner(void);\nvoid rtc_timer_set_prescaler(int16_t prescaler);\nvoid rtc_timer_set_cc0(int32_t cc0);","memory-mapped-io-mmio#Memory-Mapped I/O (MMIO)":"Direct register access utilities:\n#include \"mmio.h\"\n// 32-bit register access\nuint32_t reg_value = reg_read32(BASE_ADDR + OFFSET);\nreg_write32(BASE_ADDR + OFFSET, value);\n// 16-bit register access  \nuint16_t reg_value = reg_read16(BASE_ADDR + OFFSET);\nreg_write16(BASE_ADDR + OFFSET, value);\n// 8-bit register access\nuint8_t reg_value = reg_read8(BASE_ADDR + OFFSET);\nreg_write8(BASE_ADDR + OFFSET, value);","communication-interfaces#Communication Interfaces":"","serialtl-tilelink-over-uart#SerialTL (TileLink over UART)":"High-level TileLink transactions:\n// Read from address\nuint32_t data = tl_read32(address);\n// Write to address  \ntl_write32(address, data);\n// Burst operations\ntl_burst_read(start_addr, buffer, length);\ntl_burst_write(start_addr, buffer, length);","analog-scan-chain#Analog Scan Chain":"Access analog configuration registers:\n// Configure analog block\nasc_write_register(block_id, reg_addr, value);\n// Read analog status\nuint32_t status = asc_read_register(block_id, reg_addr);","debugging-and-testing#Debugging and Testing":"","printf-support#Printf Support":"BUILD_MODE Compatibility: printf is ONLY supported in BUILD_MODE=SIM. Using printf in BUILD_MODE=BRINGUP will lock up the CPU because HTIF is not available on hardware.\nThe firmware includes printf support via HTIF (Host-Target Interface) for simulation only:\n#include \"htif.h\"\n// Only available in BUILD_MODE=SIM\nprintf(\"Debug: value = %d\\n\", variable);\nprintf(\"Status: 0x%08x\\n\", register_value);","simulation-utilities#Simulation Utilities":"BUILD_MODE Compatibility: sim_utils functions are ONLY available in BUILD_MODE=SIM. These are not accessible in BUILD_MODE=BRINGUP.\n#include \"sim_utils.h\"\n// Simulation-specific functions (SIM mode only)\nsim_exit(exit_code);\nsim_checkpoint(\"test_point_1\");","memory-dump-and-analysis#Memory Dump and Analysis":"Generate firmware analysis:\nmake objdump          # Create disassembly\ncat objdump.txt       # Review assembly output","best-practices#Best Practices":"","memory-management#Memory Management":"SCuM-V has limited memory resources. Optimize data structures and avoid dynamic allocation where possible.\nUse fixed-size buffers\nMinimize stack usage in interrupt handlers\nLeverage const data placement in ROM","power-optimization#Power Optimization":"// Use interrupt-driven UART I/O\nHAL_UART_enableRXInterrupt(UART0, 1);  // Enable RX interrupt when 1 byte available\nHAL_UART_enableTXInterrupt(UART0, 1);  // Enable TX interrupt when TX FIFO has space\n// Direct register access for power management\nreg_write32(PERIPHERAL_BASE + POWER_CTRL, POWER_DOWN_MODE);","interrupt-handling#Interrupt Handling":"void uart_rx_handler(void) __attribute__((interrupt(\"machine\")));\nvoid uart_rx_handler(void) {\n    // Check if RX data is available\n    if (HAL_UART_getRXFIFODepth(UART0) > 0) {\n        uint8_t data;\n        HAL_UART_receive(UART0, &data, 1, 0);  // Non-blocking read\n        \n        // Process received data\n        process_uart_data(data);\n    }\n}","deployment-and-programming#Deployment and Programming":"","programming-via-fpga-controller#Programming via FPGA Controller":"","build-firmware#Build Firmware":"cd sw/scum_firmware\nmake","program-via-serialtl#Program via SerialTL":"cd sw  \npython tl_host.py --program firmware.bin","verification#Verification":"Monitor UART output for debug messages\nUse logic analyzer to verify communication protocols\nCheck power consumption during operation\nNext Steps: API Reference →"}},"/fpga-setup":{"title":"FPGA Programming","data":{"":"Complete guide for programming and configuring the FPGA for SCuM-V development.","prerequisites#Prerequisites":"Vivado 2025.1 (Recommended and tested)\nArty A7-100T FPGA board\nProper hardware connections (see Hardware Setup)\nThis guide is tested with Vivado 2025.1 on Windows. Other versions may work but compatibility is not guaranteed.","scum-v-controller-setup-recommended#SCuM-V Controller Setup (Recommended)":"The SCuM-V Controller FPGA implementation supports both SerialTL (digital interface) and Analog Scan Chain (ASC) for comprehensive chip communication.","project-structure#Project Structure":"","quick-start#Quick Start":"","open-vivado-20251#Open Vivado 2025.1":"Launch Vivado and prepare for project creation","navigate-to-project-directory#Navigate to Project Directory":"cd C:/path/to/scum-v-bringup/hw/scumv-controller","generate-vivado-project#Generate Vivado Project":"source create_project.tcl","build-bitstream#Build Bitstream":"In Flow Navigator: Generate Bitstream\nWait for compilation to complete","program-device#Program Device":"Connect Arty A7-100T via USB\nFlow Navigator → Open Target → Select Arty A7-100T\nProgram Device\nVerification: LED2 should turn on (indicates SCAN_CLK activity)","alternative-vivado-gui-workflow#Alternative: Vivado GUI Workflow":"If you prefer the graphical interface:\ncd hw/scumv-controller\nsource create_project.tcl\nThen use the Vivado GUI for synthesis, implementation, and programming.","legacy-scanchain-implementation#Legacy Scanchain Implementation":"The scanchain-only implementation is legacy/optional. Use SCuM-V Controller for full functionality.\nFor ASC-only UART adapter:","navigate-to-legacy-project#Navigate to Legacy Project":"cd C:/path/to/scum-v-bringup/hw/scanchain","generate-project#Generate Project":"source create_project.tcl","follow-build-and-programming#Follow Build and Programming":"Follow same build and programming steps as above","simulation-environment#Simulation Environment":"","scum-v-controller-simulation#SCuM-V Controller Simulation":"Primary Testbench: hw/scumv-controller/sim/scumv_controller_integration_tb.vConfiguration:\nUART Baud Rate: 2,000,000\nTest Vectors: Generated with sw/tl_host_sim.py\nDocumentation: See hw/scumv-controller/sim/TEST_VECTORS_README.md\nFeatures:\nConsole Logging: Testbench mirrors prints to scumv_controller_integration_tb.log\nFlow Control: Models backpressure by deasserting TL input ready intermittently\nComprehensive Testing: Supports read/write/mixed transaction patterns","test-vector-generation#Test Vector Generation":"Generate custom test patterns:\ncd sw\npython tl_host_sim.py\nThis creates binary test files for simulation:\nsingle_read_test.bin - Basic read operations\nsingle_write_test.bin - Basic write operations\nstl_mixed_5pkts.bin - Mixed read/write transactions\nstl_flash_stress_4096pkts.bin - Stress testing","qspi-flash-programming-optional#QSPI Flash Programming (Optional)":"For persistent FPGA configuration across power cycles:","prerequisites-1#Prerequisites":"Successful bitstream generation\nReference: Arty Programming Guide","flash-device-selection#Flash Device Selection":"Important: Most new Arty A7-100T boards use s25fl128sxxxxxx0-spi-x1_x2_x4 flash device. Verify your specific board's flash type.","programming-steps#Programming Steps":"","generate-configuration-file#Generate Configuration File":"In Vivado: Tools → Generate Memory Configuration File\nSelect appropriate flash device\nGenerate .bin file","program-flash#Program Flash":"Tools → Program Flash\nSelect generated .bin file\nProgram and verify","version-control-integration#Version Control Integration":"","tcl-script-generation#Tcl Script Generation":"For maintaining version control compatibility:\nGenerate Project Script\nFile → Project → Write Tcl...\nUncheck \"Copy sources to new project\"\nSave as create_project.tcl\nClean Generated Script\nRemove references to *.dcp files\nRemove utils_1 folder references\nFix file paths: ${origin_dir}/../../[path] → ${origin_dir}/[path]\nThis workflow based on FPGA Developer's Version Control Guide with updates for current Vivado versions.","testing--verification#Testing & Verification":"","basic-functionality-test#Basic Functionality Test":"","program-fpga#Program FPGA":"Load SCuM-V Controller bitstream onto the device","verify-led2-activation#Verify LED2 Activation":"Confirm SCAN_CLK indicator LED2 turns on","check-uart-interface#Check UART Interface":"Ensure COM port is detected by your system\nFor detailed communication testing and firmware loading, proceed to the Bootloading Guide →.\nNext Steps: Bootloading Guide → - Load and execute firmware on SCuM-V"}},"/hardware-setup":{"title":"Hardware Setup","data":{"":"Setting up the SCuM-V hardware development environment.\nWork in progress.\nNext Steps: FPGA Programming Guide →"}},"/":{"title":"SCuM-V Bringup & Development","data":{"":"Development toolkit for the Single-Chip Micro Mote V (SCμM-V) system-on-chip (SoC).This repository contains FPGA controllers, host software, firmware, and documentation used in bringup.","quick-start#Quick Start":"Hardware Setup →Complete guide for setting up your SCuM-V development environment with FPGA boards and level shifters. Includes equipment checklist, PCB connections, and power supply configuration.\nFPGA Programming →Program the Arty A7 FPGA with SerialTL controller and analog scan chain interfaces. Covers Vivado project setup, bitstream generation, and simulation.\nFirmware Development →Develop and flash RISC-V firmware for the SCuM-V chip using our BSP and examples. Includes toolchain setup and debugging tools.\nBootloading Guide →Use Python host tools to communicate with SCuM-V via SerialTL and analog scan chain. Programming and debugging the chip.","technical-documentation#Technical Documentation":"","core-systems#Core Systems":"System Overview - Architecture and block diagrams\nDigital Core - RISC-V processor and memory system\nDigital Baseband - Wireless communication modem","analog-subsystems#Analog Subsystems":"Power System - DC-DC converters and voltage regulation\nClock Generation - Oscillators and timing systems\n2.4 GHz Radio - Wireless transceiver front-end\n94 GHz Radar - High-frequency radar system\nPrecision ADC - Sensor interface and data acquisition","development-resources#Development Resources":"API Reference - SerialTL commands and register maps","getting-help#Getting Help":"Issues: Report bugs and request features on GitHub\nDocumentation: Browse the navigation menu for detailed guides\nLegacy Docs: SCuM-V23 Archive for previous generation\nThis project is developed as part of UC Berkeley's EE194/EE290C Special Topics in Circuit Design course."}},"/oscillators":{"title":"Oscillators","data":{"":"This section is incomplete and contains placeholder questions for documentation completion.\nThe following topics need to be documented:\nWhat clock domains are present?\nHow is the system intended to work if fully functional?\nWhat tuning accessibility do we have?\nWhat are minimum/maximum frequencies?"}},"/overview":{"title":"Overview","data":{"":"This document describes the Single-Chip Micro Mote V (SCuM-V), a 16nm system-on-chip (SoC) for internet-of-things (IoT) applications.The SoC is designed around the RISC-V 5-stage in-order Rocket processor, generated by the RocketChip generator, embedded in the Chipyard framework. It features a crystal-free design with custom dual-mode IEEE 802.15.4 and Bluetooth Low Energy (BLE) transceiver. The SoC is implemented in the Intel 16 FinFET process.The SCuM-V chip offers several GPIO pins, a single UART bus, QSPI Flash, and an on-chip, crystal-free RTC with capture and compare registers.\nThis iteration of the chip did not support I2C or cryptographic acceleration.SCuM-V24 has several new features introduced over its predecessor SCuM-V23 including a new RTC peripheral, an Analog Frontend, two different radio receive chains (one traditional, one experimental), and an Analog oscillator PI controller.","block-level-diagram--chip-features#Block Level Diagram + Chip Features":"","32-bit-risc-v-core#32-bit RISC-V Core":"The SoC includes a 32-bit Rocket, which has a high-performance single-issue in-order execution pipeline, with a peak sustainable execution rate of one instruction per clock cycle. The core supports Machine and User privilege modes as well as standard Integer, Multiply, Atomic, Floating-Point and Compressed RISC‑V extensions (RV32IMAFC).Detailed description of the core is in the digital core section","on-chip-memory-system#On-Chip Memory System":"The Rocket core has a 8kB I$ and D$ and a 256kB scratchpad acting as L2 memory.","busses#Busses":"The design includes a system, peripheral, control, and front bus. The Rocket Tile communicates through the system bus to the remaining three buses. The control bus accesses BootROM, PLIC/CLINT, and the debug interface. The frontend bus handles DMA devices.","interrupts#Interrupts":"Two interrupt controllers for handling MMIO are attached to the control bus, the platform level interrupt controller and the core local interrupts. Core local interrupts are used for timer and the software while the PLIC interacts with the peripherals.","dual-mode-bleieee-802154-transceiver#Dual-Mode BLE/IEEE 802.15.4 Transceiver":"A dual-mode transceiver that supports both Bluetooth Low-Energy and IEEE 802.15.4 modes of operation. In the Bluetooth LE operating mode, the transceiver is capable of sending and receiving BLE Link Layer packets at a rate of 1Msym/s. In IEEE 802.15.4 operating mode, the transceiver sends and receives 802.15.4 PHY packets at 2 Msym/s.The CPU is able to provide packet payloads to the digital baseband using DMA. Incoming packets will trigger multiple interrupts and provide the packet to the CPU via DMA. Control, status, and tuning registers are exposed to the CPU via MMIO. This includes a large suite of parameters of the transceiver (e.g. radio mode, channel tuning) that are accessed with these memory-mapped registers."}},"/power-system":{"title":"Power System","data":{"":"SCuM-V24B has 3 power domains:\nVDD_A - 1V, 5mA expected\nVDD_RF - 1V, 15mA expected\nVDD_D - 0.85V, 15mA expected","switched-capacitor-converter#Switched Capacitor Converter":"Ladder 3:1 Topology\nAll capacitors & switches are rated at Vout.\nExternally Reconfigurable for 3:1, 2:1, 3:2 for exploiting full battery voltage range.\nSwitched capacitor converter schematic:\nSimulated Efficiency Variation with Load(Left) Efficiency Variation with Load. (Right) Vout Variation with Load:\nSimulated performance\nSimulated Performance Parameters\tDetails\tClock Frequency\t85MHz-120MHz\tPeak Power Efficiency\t75% (Pre-layout)\tFull-load Efficiency\t68% (Pre-layout) and <50% (Post-layout)\tMax Vout_ripple (pk-pk)\t50 mVpp\tPower Density at full-load\t65mW/mm² @100MHz\t\nOverview of High-Level Power Converter Design\nParameters\tDetails\tTotal Capacitance\t6.5nF\tCapacitor Type\tMOM+MOS\tVin Range\t4.2 V-3V\tVout Range\t1.8V-1.1V\tConversion Ratios\t3:1, 2:1\tLoad Range\t5mA to 30mA\tSwitched-Capacitor Area\t450,000 um² (75% of Power Block)\tMax Output Power\t30 mW","low-dropout-ldo-voltage-regulators#Low Dropout (LDO) Voltage Regulators":"The design of the LDO is a 2-stage amplifier where the output of the differential amplifier drives the gate of the PMOS at the second stage and the output of the drain of this PMOS is the regulated voltage. This voltage is then passed through a resistor-feedback network to get the desired regulated voltage for different power domains. An additional capacitor is attached at the output voltage as well to stabilize the LDO. Since each domain requires different voltages, the resistors values were chosen to such that the feedback yielded the desired voltage for different domains (1V for the RF analog, and 0.85V for Digital).Simulated performance\nParameter\tLDO_RF (1 V)\tLDO_Digital (0.85 V)\tLDO_Analog (1 V)\tVin\t1.8 V - 1.2 V\t1.8 V - 1.2 V\t1.8 V - 1.2 V\tVout range (at full load)\t1.08 V - 0.81 V\t0.83 V - 0.73 V\t1.19 V - 0.978 V\tMax Output Power\t15 mW\t15 mW\t5 mW","current-reference#Current Reference":"Distributes 2 uA current reference to other blocks, includes a start-up circuit.Parasitic extraction results:\nTypical conditions yields reference current ranging from 1.98 uA to 2.4 uA (~20% variation)\nLarge variation with corners\nWorst case: ff_hot at 3.04 uA","bandgap-reference#Bandgap Reference":"The Bandgap Reference Circuit (BGR) can be splitted into 3 parts: startup circuit, 2-stage op-amp, and the core BGR circuit. There are 2 included RDACs for the temperature coefficient and output voltage (Vref) adjustment.Key parameters and simulated performance\nParameter\tSpec\tOutput, VBAT=1.6V\t~650 mV\tPower Consumption, T=27C\t~1.8 mW\tPSRR, f=1 MHz\t~58 dB\tLayout Area\t~ 7,500 um²","core-bgr-circuit#Core BGR Circuit":"The temperature compensation coefficient is determined by the ratio of R3/R2, while the output voltage level is determined by the ratio of R4/R2, assuming R1=R2. R3 and R4 are eventually implemented as RDACS to enable tuning of temperature coefficient and output voltage shifting for LDO Vref supply.","2-stage-op-amp#2-Stage Op-Amp":"A two stage opamp with Miller compensation and pole cancellation was used.","utility-current-dac#Utility Current DAC":"Utility Current DAC schematic:\nKey parameters and simulated performance\nParameter\tSpec\tOutput @ 1.6 V\tUp to 63 * IREF\tPower @ 126 uA\t~50 uW\tInput Current Range\t[0.1 uA, 20 uA]\tLoad Voltage\t~ 150 mV\tAverage DNL Error\t1.73%\tOverall INL Error\t~2 uA\tEstimated Area\t800 um²\t\n6-bit binary weighted current mirror scaling\nUses IREF input as LSB"}},"/radar":{"title":"94 GHz FMCW Radar Transmitter","data":{"":"The frequency-modulated continuous wave (FMCW) radar transmitter is designed to generate linear chirps with the following high-level specifications:\nParameter\tValue\tCenter frequency\t94 GHz\tMaximum chirp bandwidth\t1 GHz\t\nLinear chirps over time with a center frequency of 94 GHz:The radar transmitter is implemented with a Class A voltage-controlled 47 GHz oscillator with a varactor driven by a ramp voltage.\nThe ramp voltage is generated digitally by an 8-bit counter register whose output feeds into an R-2R DAC.\nThe output of the VCO is fed into a frequency doubler, and the resulting 94 GHz signal is amplified by the PA.A center frequency of 94 GHz was chosen because Yahia, a graduate student advised by Prof. Niknejad, had recently taped out a 90 GHz PA in February 2023 and Prof. Niknejad suggested to use Yahia's PA for this radar transmitter. As a result, the PA is courtesy of Yahia.","system-overview#System Overview":"Radar system-level diagram:\nUnlike the other blocks on the chip, the radar transmitter has two dedicated power rails, VDD_RADAR and VDD_PA, that are not regulated internally and must be sourced externally. Nominally, VDD_RADAR should be 1 V, and VDD_PA should be 0.75 V.","ramp-generator#Ramp Generator":"The ramp generator is a digital circuit responsible for outputting an 8-bit ramp output that feeds into the R-2R DAC. Internally, there is a 32-bit counter register that is clocked by the CPU clock and used to generate the ramp output.There are two states of the ramp generator: STATE_IDLE and STATE_RAMP.\nIn STATE_IDLE, the ramp generator waits for ramp_generator_num_idle_cycles clock cycles before it moves to the STATE_RAMP state.\nIn STATE_RAMP, the ramp output is initially set to ramp_generator_frequency_step_start. Every ramp_generator_num_cycles_per_frequency clock cycles, the ramp output is incremented. Once the ramp output has been incremented ramp_generator_num_frequency_steps times, the ramp output is reset to ramp_generator_frequency_step_start, and the state machine moves back to the STATE_IDLE state. The ramp is now complete.\nThe reason for allowing the CPU to set ramp_generator_frequency_step_start as well as ramp_generator_num_frequency_steps is that the varactor's capacitance is non-linear with respect to the control voltage. Therefore, the control registers should be set, so that the ramp voltage causes the VCO to sweep linearly over the desired chirp bandwidth.Ramp generator output:","r-2r-dac#R-2R DAC":"The R-2R DAC converts the 8-bit ramp output from the ramp generator into an analog ramp voltage between 0 V and 1 V that controls the varactor in the VCO.\nThe resistor values used are 1k and 2k.","vco#VCO":"The VCO is a class A VCO with a 4-bit capacitive DAC ranging from 2 fF to 16 fF.\nUnlike the capacitive DAC, where a higher tuning code corresponds to a lower frequency, the varactor's capacitance decreases as a function of the control voltage. However, since the frequency is sensitive to the control voltage, the control voltage is not brought out as a debug signal.\nIn simulation, the VCO draws about 7 mW of power.VCO schematic:","frequency-doubler#Frequency Doubler":"The frequency doubler uses a modified cross-coupled pair with a resonant LC tank to double the VCO output's frequency.\nIn simulation, the frequency doubler draws about 16 mW of power.Frequency doubler schematic:","pa#PA":"The PA was designed and laid out by Yahia with minor modifications for SCuM-V24B.\nThe PA consists of a driver stage and an output stage and consumes up to 60 mA at a supply voltage of 0.75 V.","register-map#Register Map":"The radar configuration registers are part of the Scumvtuning block, which contains a set of memory-mapped registers for tuning analog blocks. The base address of Scumvtuning is 0x0000_A000.\nRegister\tName\tSize (bits)\tFunction\t0x0D\tramp_generator_clk_mux_sel\t1\tUnused.\t0x0E\tramp_generator_enable\t1\tInitial 1b'1.Enables the ramp output.\t0x0F\tramp_generator_frequency_step_start\t8\tInitial: 8b'0.Sets the initial ramp output for each ramp.\t0x10\tramp_generator_num_frequency_steps\t8\tInitial: 8b'0.Sets the number of LSBs the ramp output should increment by for each ramp.\t0x11\tramp_generator_num_cycles_per_frequency\t24\tInitial: 24b'0.Sets the number of clock cycles before incrementing the ramp output.\t0x14\tramp_generator_num_idle_cycles\t32\tInitial: 32b'0.Sets the number of clock cycles to idle between ramps.\t0x18\tramp_generator_rst\t1\tInitial: 32b'1.Resets the ramp generator's counter and ramp output.\t0x19\tvco_cap_tuning\t5\tInitial: 5b'0.Tunes the 4-bit capacitive DAC of the VCO. The MSB is unused.\t0x1A\tvco_enable\t1\tInitial: 1b'1.Unused.\t0x1B\tvco_div_enable\t1\tInitial: 1b'1.Unused.\t0x1C\tpa_enable\t1\tInitial: 1b'1.Unused.\t0x1D\tpa_bypass\t1\tInitial: 1b'0.Unused.\t0x1E\tpa_input_mux_sel\t1\tInitial: 1b'0.Unused.","layout#Layout":"Final radar layout: The total area is 300 um x 200 um."}},"/radio":{"title":"2.4 GHz Transceiver","data":{"radio-architecture#Radio Architecture":"The radio operates within the frequency range 2.4 to 2.4835 GHz covering 70 1MHz RF channels. The receive chain should be sensitive to an input power range of -70 dBm to -10 dBm and achieve a BER of 0.1% or an SNR of 12.5 dB.","radio-final-block-diagram#Radio Final Block Diagram":"","system-overview#System Overview":"The SCuM-V24B radio subsystem includes:\nLow Noise Amplifier (LNA): Provides initial signal amplification\nMixer: Frequency down-conversion for baseband processing\nTransimpedance Amplifier (TIA): Current-to-voltage conversion\nBandpass Filter (BPF): Channel selection and filtering\nVariable Gain Amplifier (VGA): Adjustable signal amplification\nVoltage Controlled Oscillator (VCO): Local oscillator generation","transmitter#Transmitter":"The transmitter is designed to operate in the 2.4 GHz ISM band and be standards-compliant with IEEE 802.15.4 and BLE. The tuning range of the 4.8 GHz DCO is 4.88 GHz ± 0.5 GHz with less than 40 ppm of resolution (less than 192 kHz), corresponding to 2.44 GHz ± 0.25 GHz after the divider.Transmitter schematic: The divider divides the 4.8 GHz DCO signal down to 2.4 GHz and also generates the differential in-phase and quadrature components for the mixer.","system-diagram#System Diagram":"The radio system is optimized for low-power operation while maintaining sufficient sensitivity for IoT applications.","key-specifications#Key Specifications":"Parameter\tValue\tFrequency Range\t2.4 - 2.4835 GHz\tNumber of Channels\t70 × 1MHz\tSensitivity\t-70 to -10 dBm\tTarget BER\t0.1%\tRequired SNR\t12.5 dB\tVCO Tuning Range\t4.88 GHz ± 0.5 GHz","design-considerations#Design Considerations":"IEEE 802.15.4 and BLE compatibility\nLow power consumption for battery operation\nIntegrated antenna interface\nDigital control for frequency selection\nOptimized for single-chip integration\nFor detailed register maps and configuration information, refer to the complete system documentation."}},"/uv-adc":{"title":"UV-Precision Delta-Sigma ADC","data":{"":"The µV-Precision ADC is designed to function as an EEG front-end with high-level specifications:\nParameter\tValue\tResolution\t18 bits\tNoise\t1.0 µVrms\tInput Bandwidth\t500 Hz\tSpot Noise\t45 nV/√Hz\t\nThe ADC is implemented with a delta-sigma architecture, leveraging a high oversampling ratio to achieve high resolution and low noise. The input drives a current controlled oscillator, which is sampled by the on-chip 32 MHz clock to generate a digital bitstream. The bitstream is then processed by a digital decimation filter to generate the final output sample.","system-level-diagram-and-description#System-level Diagram and Description":"","analog-front-end#Analog Front-End":"Documentation incomplete: Input impedance? Mins and maxs?","digital-front-end#Digital Front-End":"The delta-sigma ADC's DSP chain is implemented as a cascaded integrator comb (CIC) decimation filter for noise shaping. The key CIC filter parameters for this design are N=4, R=8000, M=1Digital Front-End system-level diagram:The digital frontend features self-generated, software-programmable chopper clock generators for 1st and 2nd stage choppers. A digital de-chopper/mixer with configurable clock delay to match delay of the analog front-end is also implemented.","register-map#Register Map":"The base address of the sensor ADC DSP block is 0xB000. All registers in the table below are specified as offsets from the base address 0xB000.\nRegister\tName\tSize\tFunction\t0x00\tADC_STATUS\t32\tADC_STATUS<11:6> - ADC Counter PADC_STATUS<5:0> - ADC Counter N\t0x04\tADC_DATA\t20\tRead ADC sample from FIFO\t0x08\tADC_TUNING_0\t8\tADC_TUNING_0<5:0> - Current DACADC_TUNING_0<6> - BIAS P + ADC_TUNING_0<7> - BIAS N\t0x09\tADC_TUNING_1\t8\tReserved\t0x0A\tADC_TUNING_2\t8\tADC_TUNING_2<0> - Sensor VDD mux select\t0x0B\tADC_TUNING_3\t8\tADC_TUNING_3<7:0> - Reserved\t0x0C\tADC_CHOP_CLK_DIV_1\t32\t1st stage chopper clock divider\t0x10\tADC_CHOP_CLK_DIV_2\t32\t2nd stage chopper clock divider\t0x14\tADC_CHOP_CLK_EN\t2\tADC_CHOP_CLK_EN<0> - Enable 1st stage chopperADC_CHOP_CLK_EN<1> - Enable 2nd stage chopper\t0x18\tADC_DSP_CTRL\t8\tADC_DSP_CTRL<0> - Enable dechopper in DSP chainADC_DSP_CTRL<1> - Select chopper clock used in the dechopperADC_DSP_CTRL<5:2> - Dechopping clock delay, from 0 to 15 cycles"}}}